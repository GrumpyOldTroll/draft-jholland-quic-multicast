{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-11-17T00:32:31.878969+00:00",
  "repo": "GrumpyOldTroll/draft-jholland-quic-multicast",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "humor",
      "description": "live, laugh, love",
      "color": "88C19D"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOG6NyZs5H-mEc",
      "title": "Clients should be able to tell if data came from multicast or unicast",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/1",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Last sentence of section 2 reads: \r\n\r\n`An application using a multicast-capable QUIC implementation that receives a datagram or stream data has no knowledge at the application layer whether multicast was used or not used for that data, it will only know it has received unidirectional server-to-client application data.`\r\n\r\nAs the security and privacy guarantees for data that has been delivered over multicast are (inherently) lower than over unicast, I feel like this could cause serious issues for applications. I think that any implementation that supports multicast delivery has to at least make it clear to the application that the data has been delivered over multicast, or even better yet only allow multicast delivery if the application opted in for it. ",
      "createdAt": "2022-04-19T00:48:52Z",
      "updatedAt": "2022-04-21T05:57:00Z",
      "closedAt": "2022-04-21T05:57:00Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "+1, yes thanks and good point.  I should probably add \"if the receiver has opted into receiving multicast\".",
          "createdAt": "2022-04-19T05:39:42Z",
          "updatedAt": "2022-04-19T05:39:42Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Closed with https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/6",
          "createdAt": "2022-04-21T05:57:00Z",
          "updatedAt": "2022-04-21T05:57:00Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOG6NyZs5H-mh6",
      "title": "Delivery of MC_SESSION_PROPERTIES over multicast",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/2",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 9.1: \r\n\r\n`An MC_SESSION_PROPERTIES frame (type=TBD-01) is sent from server to client, either with the unicast connection or in an existing joined multicast session.`\r\n\r\nIs there any reason that this couldn't always be delivered just over the unicast stream? As the AEAD key and algorithm are mutable, I think this might expose an unnecessary attack vector. By only having it on the unicast stream its safer for both the server (as it knows all recipients that will get it) as well as the client (as it knows it comes from the legitimate source). ",
      "createdAt": "2022-04-19T00:52:57Z",
      "updatedAt": "2022-05-02T18:08:11Z",
      "closedAt": "2022-05-02T18:08:11Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I don't think it costs much to send this always over unicast, but I'm also not sure it buys you anything on security.  My thought here was that you've exposed updates only to those who already had access to the stream.\r\n\r\nI guess in the forward secrecy case if the shared key was leaked from a confederate, they'd have to maintain a unicast listener to get the next update.  So maybe it's worth a little bit on security.  It's a fair point I guess.  I'm a little 'meh', the tradeoff seems relatively minor in both directions.  My plan was to leave it up to the server, but I'm fine with forbidding it also I guess.",
          "createdAt": "2022-04-19T05:47:35Z",
          "updatedAt": "2022-04-19T05:47:35Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess to me it's also about separation of concerns where the multicast session is just data and all the control data goes over the unicast connection. Though I guess due to PATH_CHALLENGE frames that won't be entirely possible either way so I agree with your \"meh\", I guess in the end it won't matter. ",
          "createdAt": "2022-04-19T14:26:43Z",
          "updatedAt": "2022-04-19T14:26:43Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Ah, I see.  I was thinking more like \"data is data\", and data that's the same for a whole bunch of clients is useful to send over multicast whether it's control or application data.  I was basically aiming to disallow only those frames that don't make sense because of the \"unidirectional alternate path\" part.\r\n\r\nSimilar to PATH_CHALLENGE, I think things like PING and PADDING might be needed just for practical purposes, and the INTEGRITY frames are I think pretty useful to permit over other multicast sessions, since they otherwise make a new unicast scaling limit.  (I guess that shouldn't really matter if you're scaled appropriately to have a graceful full-unicast fallback the way you should be, but it seems like even 3% of the unicast baseline can get to be a lot so it's potentially worth offloading...). The other frames are maybe less important, but I didn't see a reason to exclude them.\r\n\r\nImproving security would be a good reason though.  But even there, if there's a threat model from a pervasive monitoring attacker getting a key leaked from some unicast context and then losing that access but staying joined to follow all the key updates (whereas he'd otherwise have to keep access to a unicast endpoint), then it seems to me the right answer might be to put the key updates on the unicast channel, but other changes to mutable properties on the multicast channel still could be usefully sent over the session, since they're the same for everyone.  (The changes for the keys and for the other things could just be sent in separate MC_SESSION_PROPERTIES frames.).\r\n\r\nAnyway, I guess I'm thinking to close this for now if we're both 'meh', and either reopen or make a new issue if we later find a reason it makes a difference.",
          "createdAt": "2022-04-21T07:01:17Z",
          "updatedAt": "2022-04-21T07:01:17Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, I had another idea: if the only issue is forward secrecy, what if a recommendation is added that every nth MC_SESSION_PROPERTIES should be delivered over unicast to break the chain of endless forward secrecy violations? ",
          "createdAt": "2022-04-21T07:42:18Z",
          "updatedAt": "2022-04-21T07:42:18Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "That seems reasonable.\r\n\r\nBut this is more like every N key rotations, and only has to count updates containing a new key, updates to other properties probably shouldn't be counted.",
          "createdAt": "2022-04-25T06:57:48Z",
          "updatedAt": "2022-04-25T06:57:48Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOG6NyZs5H-m_g",
      "title": "ack-eliciting packets",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/3",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should there be an inclusion that packets including any of the Frames sent over the multicast stream are not ack-eliciting? I assume the intention is to not send ACK frames on the multicast streams but rather use MC_SESSION_ACK. Should there then also be a not ack-eliciting MC_DATA frame that carries the multicast data? Otherwise if STREAM frames are used they would also be ACK eliciting. ",
      "createdAt": "2022-04-19T00:57:43Z",
      "updatedAt": "2022-04-21T15:23:25Z",
      "closedAt": "2022-04-21T15:23:25Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "What I was thinking is that ack-eliciting frames will elicit an MC_SESSION_ACK on the unicast channel instead of a normal ACK, since there is no reverse path for packets sent over multicast.  Good catch, this should be explicitly spelled out.  Same for MC_PATH_RESPONSE when a PATH_CHALLENGE is received.",
          "createdAt": "2022-04-19T05:50:54Z",
          "updatedAt": "2022-04-19T05:50:54Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Closed via https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/8",
          "createdAt": "2022-04-21T15:23:24Z",
          "updatedAt": "2022-04-21T15:23:24Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOG6NyZs5H-qYO",
      "title": "What *is* a multicast session?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/4",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am confused about what a multicast session actually is. Section 2:\r\n\r\n`A multicast session (or just session) is a one-way communication stream`\r\n\r\nSo is it just a (special) QUIC stream? If so, does Session ID in 9.2 just mean stream ID? \r\n\r\nBut if it is just a stream, what is the point of the Max Streams field in MC_SESSION_PROPERTIES (and why is it mutable)?",
      "createdAt": "2022-04-19T01:27:35Z",
      "updatedAt": "2022-04-21T15:23:48Z",
      "closedAt": "2022-04-21T15:23:47Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "It's a one-way analog of a connection, the session id replaces the connection id in the 1-rtt packets.  The intent is that streams and datagrams can be carried within a packet for a multicast session, just as they can be carried in a connection.\r\n\r\nI see now that you've quoted it that \"one-way communication stream\" is a bad phrasing since it collides with \"stream\".  Maybe \"one-way analog of a QUIC connection\" would be a better phrasing?",
          "createdAt": "2022-04-19T05:54:40Z",
          "updatedAt": "2022-04-19T05:54:40Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, if it is the analog of a connection I am quite confused about how the interaction between the two (or more) will actually look like. Who creates the session, the unicast connection? If its a connection analog wouldn't it have to go through a handshake? Wouldn't this also require a pretty significant API between the connection and the session? \r\n\r\nIn my mind I always imagined everything living in the same connection and the multicast data would just be on a one directional stream. The server would initiate the stream(s) after learning from the client what its limits are. It would then send a frame (e.g. MC_SESSION_PROPERTIES) over that stream using unicast. That frame would then trigger the client to issue an IGMP/MLD join. From there on the data received via multicast would be pipelined into the stream, processed(decrypted, integrity checked) and then delivered to the application. Though I am sure there are good reasons I have missed that would prevent it being done this way. ",
          "createdAt": "2022-04-19T14:38:01Z",
          "updatedAt": "2022-04-19T14:38:01Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I was thinking about this a bit more.  \"Analog to a connection\" is wrong, you're correct.  I'll try again:\r\n\r\nI think maybe it's a unidirectional network path that can be shared by multiple connections.\r\n\r\nThe session id uses the same slot in a packet as a connection id does, and it's used in a similar way as a connection id is used, to link packets received to a connection.\r\n\r\nI don't think it's a one-directional stream (in the [quic usage](https://www.rfc-editor.org/rfc/rfc9000.html#name-streams) of the term \"stream\") because many one-directional streams can exist on the same network path.  (For instance, it's fairly common when using quic to send one object per stream.)\r\n\r\nBut everything else you described I think matches my intent (except I separated the JOIN from the PROPERTIES as separate frames):\r\nFrom the receiver's point of view, all the data received from the session is part of the single same connection with the server.  When a packet is received it's decrypted and integrity checked, then the frames in the packet are processed as any other frames in the connection--any STREAM frame received will get data passed to the application immediately if it's in-order for the stream (otherwise if there are gaps that stream will have to wait for retransmit, though other streams can progress).  Any DATAGRAM frame causes immediate delivery of application data.  Other kinds of (permitted) frames influence the connection as appropriate (e.g. PATH_CHALLENGE causes a MC_PATH_RESPONSE, PING will cause an MP_SESSION_ACK over unicast even if there wasn't application data, etc.)\r\n\r\nDoes that help any?  It's probably important to get this point clear, thanks for digging on it.",
          "createdAt": "2022-04-19T17:20:17Z",
          "updatedAt": "2022-04-19T17:20:17Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "That does clear things up, thanks. The part I am still not sure about is why there is a need for the multicast session abstraction? Maybe stream is the wrong abstraction as well, maybe it is just another path as described in multipath-quic? I guess I am still missing something somewhere...",
          "createdAt": "2022-04-20T23:31:57Z",
          "updatedAt": "2022-04-20T23:31:57Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Nvm, I just read your PR and it looks like we agree that it is another path",
          "createdAt": "2022-04-20T23:33:41Z",
          "updatedAt": "2022-04-20T23:33:41Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Closed via https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/8",
          "createdAt": "2022-04-21T15:23:47Z",
          "updatedAt": "2022-04-21T15:23:47Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOG6NyZs5H-rLe",
      "title": "MC_SESSION_INTEGRITY",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/5",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`For type TBD-05, Length is present and is a count of packet hashes. For TBD-04, Length is not present and the packet hashes extend to the end of the packet.`\r\n\r\nShould this read \"[...] extend to the end of the session.\"?",
      "createdAt": "2022-04-19T01:33:58Z",
      "updatedAt": "2022-04-21T06:10:54Z",
      "closedAt": "2022-04-21T06:10:53Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "No, this should be \"to the end of the QUIC packet\".  Compare to the phrasing and the type selection for the datagram length field: https://www.rfc-editor.org/rfc/rfc9221.html#section-4-5.2.1\r\n\r\nA MC_SESSION_INTEGRITY frame either needs a length (when followed by another frame) or it doesn't (when it extends to the end of the packet), and can maybe fit one extra hash.",
          "createdAt": "2022-04-19T05:58:37Z",
          "updatedAt": "2022-04-19T05:58:37Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh right, got it thanks. \r\n\r\nAlso, I guess it isn't in yet but shouldn't each hash now be able to be assigned to a specific packet number? If so, maybe this frame should also include a list of packet numbers. ",
          "createdAt": "2022-04-19T14:48:58Z",
          "updatedAt": "2022-04-19T14:48:58Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, my intent was that a MC_SESSION_INTEGRITY frame contains in-order packets and uses the \"packet number start\" field as the packet number of the first hash in the frame:\r\nhttps://grumpyoldtroll.github.io/draft-jholland-quic-multicast/draft-jholland-quic-multicast.html#name-mc_session_integrity\r\n\r\nI should clean that explanation up for sure, yes.",
          "createdAt": "2022-04-19T17:55:37Z",
          "updatedAt": "2022-04-19T17:55:37Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Closed via https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/7",
          "createdAt": "2022-04-21T06:10:53Z",
          "updatedAt": "2022-04-21T06:10:53Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOG6NyZs5IJvdE",
      "title": "Add something like a MC_RESERVE_SESSIONIDS frame.",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/9",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "From Max in issue #4 comment:\r\nhttps://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/8#discussion_r854656985\r\n\r\nThere should probably be a mechanic to force clients to not use some connection IDs for unicast connections. I think only doing it in the MC_SESSION_PROPERTIES frame is too late, it should probably be done immediately after the handshake of the unicast connection. Its basically a frame telling the client \"Do not use any of these connection IDs for your unicast streams as we might have a multicast session that uses this ID. If you (by sheer bad luck) already use one of them for a unicast connection (i.e. the initially created one), issue a new connection ID and retire the old one immediately.\"",
      "createdAt": "2022-04-21T05:26:02Z",
      "updatedAt": "2022-05-13T15:41:18Z",
      "closedAt": "2022-05-13T15:41:18Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Capturing the other notes from the thread:\r\nI guess session properties should implicitly reserve the session id, but also a MC_RESERVE_SESSIONIDS frame to reserve a list of IDs without sending their properties.\r\n\r\nI think if there is a collision it doesn't matter until the server issues a JOIN, but if the client has not yet migrated connection ID it can refuse the join with an \"ID Collision\" reason and we don't really need other signaling about it I think? Actually it occurs to me the server should already know if the connection ID is in use, and can determine when it has closed to retry the join?",
          "createdAt": "2022-04-21T15:21:45Z",
          "updatedAt": "2022-04-21T15:21:45Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Another option here is just an empty MC_CHANNEL_PROPERTIES, if there's space constraints and to NOT add this frame.  I think if you use a 0 content field and a 0 from packet number it's only 2 bytes of overhead.  We can make a note that server can do this to reserve channel id space even before a channel is active, and that clients SHOULD migrate away from colliding connection IDs and avoid creating colliding connection ids whenever they see a MC_CHANNEL_PROPERTIES, and then we don't need a new frame.",
          "createdAt": "2022-05-04T17:41:37Z",
          "updatedAt": "2022-05-04T17:42:12Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOG6NyZs5INviv",
      "title": "Session already has a meaning in QUIC",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/10",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\"Session\" already has a meaning in QUIC.  It appears to be implicitly imported via TLS, c.f.:\r\n - https://www.rfc-editor.org/rfc/rfc9000#section-14.2.1-4\r\n - https://www.rfc-editor.org/rfc/rfc9001.html#name-session-resumption\r\n - https://www.rfc-editor.org/rfc/rfc8446.html#section-2.2\r\n\r\nI'm thinking maybe we can search & replace \"session\" with \"channel\"?\r\n\r\n\"Channel\" also has a meaning in SSM (c.f. https://www.rfc-editor.org/rfc/rfc4607.html#page-4), but using it here would be complementary instead of divergent.  (\"Channel\" in SSM refers to a network path, and likewise if we used it instead of \"Session\" in the QUIC extensions it would refer to a network path and associated objects...)",
      "createdAt": "2022-04-21T21:17:37Z",
      "updatedAt": "2022-04-29T00:14:53Z",
      "closedAt": "2022-04-29T00:14:53Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that channel would fit well with its meaning in SSM, only thing to keep in mind is that QUIC specifies a stream as `A unidirectional or bidirectional channel of ordered bytes within a QUIC connection.`\r\n\r\nI think there should be no confusion there though. ",
          "createdAt": "2022-04-22T00:12:26Z",
          "updatedAt": "2022-04-22T00:12:26Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, I don't think that will cause nearly as much confusion as \"session\".\r\n\r\nA grep for \"channel\" in google's quiche suggests that it once had a meaning back when the project was spdy and there are some remnants still in the code, but these also have a much smaller footprint than \"session\", and I think are only in obsolete parts, c.f.:\r\n\r\n~~~\r\nnet/third_party/quiche/src/quic/core/tls_server_handshaker.cc:  // Channel ID is not supported when TLS is used in QUIC.\r\n~~~",
          "createdAt": "2022-04-25T07:05:46Z",
          "updatedAt": "2022-04-25T07:05:46Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Sessions have been renamed to channels.",
          "createdAt": "2022-04-29T00:14:53Z",
          "updatedAt": "2022-04-29T00:14:53Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOG6NyZs5IOIyE",
      "title": "Is it always necessary to acknowledge all STREAM frames?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/11",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Following QUIC mechanics, every single STREAM frame has to be acknowledged. This is done so that missing frames can be retransmitted. However, in Multicast there are several use cases where a retransmission of missing frames might not be desired (such as live video streaming) and having to acknowledge every packet creates unnecessary overhead (which at Multicast scales could add up to be quite significant). I think it might be useful to have a mechanic that replaced the acknowledgement of every frame immediately with either a bundled acknowledgment of several frames that only occurs (relatively) rarely or even just an acknowledgment that (any) data is still being received over the Multicast Channel. I guess a high max_ack_delay could be used to bundle acknowledgments, but that is set by the client. There is also not (yet) the inclusion of a mechanic that would allow for different transport properties between the unicast connection and the Multicast channels, so you would be stuck with a high max_ack_delay for unicast frames as well. ",
      "createdAt": "2022-04-22T00:06:39Z",
      "updatedAt": "2022-04-28T23:19:53Z",
      "closedAt": "2022-04-28T23:19:53Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, some kind of mechanism like this seems like a good idea.  I was originally thinking bundling could cover it, but I think you're right that it shouldn't be so tightly coupled to max_ack_delay that you have to pick between impacting your unicast recovery and requiring too many acks for multicast data, and that as it stands there's not a way to treat them separately.\r\n\r\nAs a brainstorming proposal:\r\nwhat about maybe a \"recommended ack bundle size\" as another session property that advises a client on a bundle size specific to the session to use as a target for a bundled acknowledgement count, and maybe this would override max_ack_delay for sessions below the recommended bundle size unless there is a gap in the packet sequence numbers that lasted longer than max_ack_delay or max_idle_time was exceeded (or maybe also if a ping or path challenge was received).  I think this would help with ack overhead (at least for the typical case?) without impacting unicast recovery.\r\n\r\nTo the other point you mentioned:  I think there are already mechanisms that can avoid the need for retransmits, such as RESET_STREAM and DATAGRAM, and I don't think I know any use cases that need another way? (draft-lcurley-warp for instance will use a stream per object and a reset stream if there was loss that's late enough they'd rather abandon it, I think))",
          "createdAt": "2022-04-27T01:12:46Z",
          "updatedAt": "2022-04-27T01:12:46Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, should have phrased it better, let me retry: I think the server does not always even need to know which specific packets are getting acknowledged (in cases when there is no intention to retransmit missing packets), so it might be sufficient to just send a frame saying \"Out of the last x packets I received y\" so the server can still know if/ how many dropped packets there are. I wonder if the handshake should also somehow negotiate if the server and client want reliable transmission or not. \r\n\r\nI like the idea about having a bundle size, maybe it would also be sufficient to say clients SHOULD try to fill the PMTU as good as possible? ",
          "createdAt": "2022-04-27T14:42:12Z",
          "updatedAt": "2022-04-27T14:42:12Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOG6NyZs5ISGVP",
      "title": "Client behavior when unicast connection is disrupted",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/12",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "How would a client behave if the unicast connection is interrupted but the Multicast channels still receive data? It wouldn\u2019t be able to check the integrity of any packets, but it isn\u2019t exactly idling either so the idle connection timeout would not trigger I guess? Should this be clarified so that all multicast session are left and the entire connection is shutdown if there is no message over the unicast connection for longer than the idle timeout? ",
      "createdAt": "2022-04-22T19:30:18Z",
      "updatedAt": "2022-05-18T23:19:32Z",
      "closedAt": "2022-05-18T23:19:32Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yeah, good question.  I guess maybe the client should actively ensure it still has unicast connectivity and leave sessions if it can't prove it does, on a timescale similar to max idle (or maybe another value?).\r\n\r\nI guess if client gets no packets for some time on unicast, it should probably send a ping, and if it still has no ack after some time it should leave its sessions with a reason like \"failed unicast\".  But yes, there should certainly be a section detailing the behavior, good point.",
          "createdAt": "2022-04-25T06:54:13Z",
          "updatedAt": "2022-04-25T06:54:36Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOG6NyZs5ISIBO",
      "title": "Path migration ",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/13",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What happens if the unikalster path is being migrated due to a change in NAT/ mobility? It would probably mean that all sessions should issue new IGMP/MLD reports since it\u2019s quite possible that the device is connected to a new router does not yet have forwarding state and waiting for a query might cause unnecessary delays.\r\n\r\nIt might also mean that the idle timeout for the session is (falsely) triggered as it could take some time for the join to propagate far enough upstream to receive Multicast packets once again. ",
      "createdAt": "2022-04-22T19:38:25Z",
      "updatedAt": "2022-11-15T19:08:40Z",
      "closedAt": "2022-11-15T19:08:40Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, if the client switches to a new network path it'll need to attempt rejoining its joined sessions on the new path.\r\n\r\nThat's a good point about a false idle time issue, but that's also applicable to the initial join--there maybe should be a different initial join max idle vs. the max idle after the first data is received.  If we had that, on a connection change maybe client could use the initial join max idle.  (And also maybe server should assume that unicast data is required until there start being MP_SESSION_ACKs, and this should also start immediately upon a unicast connection id change?)\r\n\r\nIt is also possible the client limits change in this scenario, such as the \"permit IPv4\" or the \"permit IPv6\" flags or the max rate.  These might require server to change the sessions the client joins.\r\n\r\nAnyway, +1, there should be a discussion of the issues that can happen on a client network change, and perhaps some guidance on how to handle it.  That's probably a whole section, with perhaps several subsections.",
          "createdAt": "2022-04-25T06:50:16Z",
          "updatedAt": "2022-04-25T06:50:16Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOG6NyZs5ISJR6",
      "title": "Max streams ",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/14",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RFC 9000, section 4.6: `Only streams with a stream ID less than \"(max_streams * 4\r\n   + first_stream_id_of_type)\" can be opened`\r\n   \r\nSince each session has its own stream ID space a different restriction might need to be specified to make sure the combination of all streams across all sessions does not exceed the limit set by max_streams.",
      "createdAt": "2022-04-22T19:45:53Z",
      "updatedAt": "2022-05-18T23:20:27Z",
      "closedAt": "2022-05-18T23:20:27Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I don't think each session has its own stream ID space necessarily.  In particular, I think missing data from a stream can be retransmitted by the unicast connection by using the same stream ID that was used in the , so I think the space is shared across the connection.\r\n\r\nBut it does probably have to say something to clarify the point, and the server has to do something to ensure the stream IDs don't collide if there's any unidirectional streams used for unicast.  I think what that is can be left up to the server.  (It could for instance use only IDs with ID % 8 == 7, leaving those for ID % 8 == 3 for unidirectional, for instance, or it could use the same internal signaling channels on the server side that ensure the servers all have access to all the session data.)",
          "createdAt": "2022-04-25T06:26:50Z",
          "updatedAt": "2022-04-25T06:26:50Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "There's some text relevant to this already in section 4.4:\r\n\r\n\"However, since clients can join later than a channel began, clients supporting the multicast extensions to QUIC should be prepared to handle stream IDs that do not begin at early values, since by the time a client joins a channel in progress the stream id count might have been increasing for a long time. Clients should therefore begin with a high initial_max_streams_uni or send an early MAX_STREAMS type 0x13 value (see Section 19.11 of [[RFC9000](https://grumpyoldtroll.github.io/draft-jholland-quic-multicast/draft-jholland-quic-multicast.html#RFC9000)]) with a high limit.\r\n\r\nMC_CHANNEL_PROPERTIES can provide a recommended value for max_streams_uni to allow for uninterrupted transport using the multicast channel.\"\r\n\r\nI think in general we still need to abide by the max_streams limits, but there's a few more tweaks and guidance we should have, including:\r\n- If a channel will exceed the max_streams of a client, the server MUST send a MC_CHANNEL_LEAVE asking for a leave at or before the packet number that will exceed it\r\n- A server MUST NOT tell a client to join a channel that will imminently exceed the MAX_STREAMS of the client.  A server MAY (or SHOULD?) send a STREAMS_BLOCKED if it is prevented from asking a client to join a channel by this constraint.\r\n- Add some flexibility on the error response from section 4.6 of RFC 9000--if a client sees a stream id exceeding its max streams that was delivered on a channel, it SHOULD (or MAY?) drop the packet and leave the channel (with a new reason?) instead of closing the connection. (This can happen with a correct server if the LEAVE the server sent was lost and so the client didn't receive it in time.)\r\n\r\nThere might be a few others, but I think at least these?",
          "createdAt": "2022-05-04T17:30:49Z",
          "updatedAt": "2022-05-04T17:32:29Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOG6NyZs5Ik_fz",
      "title": "How is a Stateless Reset handled?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/15",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/rfc/rfc9000#section-10.3",
      "createdAt": "2022-04-27T17:15:09Z",
      "updatedAt": "2022-05-02T18:06:34Z",
      "closedAt": "2022-05-02T18:06:34Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOG6NyZs5IlAIN",
      "title": "Define the server's responsibility for buffering old data",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/16",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Session data needs reliability on streams, but also servers need to not be required to buffer unbounded amounts of data.  Define what the failure modes look like.",
      "createdAt": "2022-04-27T17:16:40Z",
      "updatedAt": "2022-05-25T18:34:29Z",
      "closedAt": "2022-05-25T18:34:29Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think this issue is mostly(?) addressed by removing the STREAM_BOUNDARY (https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/28), and now server *is* required to buffer data that still needs to be sent to clients, but we do not operationally expect this data to accumulate in channels since the streams in channels will be reset when no longer needed.",
          "createdAt": "2022-05-25T18:32:04Z",
          "updatedAt": "2022-05-25T18:32:04Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "We might need to make a comment in the operational considerations section saying that the server shouldn't do things that require infinite buffering, but I'll make a separate issue from there.",
          "createdAt": "2022-05-25T18:34:29Z",
          "updatedAt": "2022-05-25T18:34:29Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOG6NyZs5IsBmD",
      "title": "Channel IDs should be carried in frames like Connection IDs",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/21",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Connection ID with a required length, e.g. https://www.rfc-editor.org/rfc/rfc9000#name-new_connection_id-frames:\r\n\r\n~~~\r\nNEW_CONNECTION_ID Frame {\r\n...\r\n  Connection ID (8..160),\r\n...\r\n}\r\n~~~\r\n\r\nInstead of (i):\r\n\r\n~~~\r\nMC_CHANNEL_INTEGRITY Frame {\r\n...\r\n  Channel ID (i),\r\n...\r\n}\r\n\r\n~~~\r\n",
      "createdAt": "2022-04-29T00:32:41Z",
      "updatedAt": "2022-05-02T11:19:23Z",
      "closedAt": "2022-05-02T11:19:23Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOG6NyZs5IyuYe",
      "title": "There are references to (S,G)s even though IP layer is allowed to be ASM",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/23",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Max pointed out that there's some places talking about (S,G)s when talking about the IP layer multicast Group or Channel, rather than \"(*,G)s or (S,G)s\" or something, but the quic channels are not restricted to only SSM (they can include ASM).  Some possible solutions:\r\n- restrict to SSM\r\n- generalize the references\r\n  - possibly by adding a term to capture \"(*,G) or (S,G)\" more succinctly",
      "createdAt": "2022-04-29T16:54:37Z",
      "updatedAt": "2022-05-05T04:12:22Z",
      "closedAt": "2022-05-05T04:12:22Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOG6NyZs5I1HaV",
      "title": "Clarify that joins are optional in the Channel Management section",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/24",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "From Sam Hurst:\r\nBe more explicit in the \"Channel Management\" section that the client is not obligated to join the multicast channel once it receives an MC_SESSION_JOIN frame. If it chooses not to, it has the option to send an MC_SESSION_STATE_CHANGE frame with the \"declined join\" reason, but that isn't actually mentioned in the session management section.",
      "createdAt": "2022-04-30T17:42:22Z",
      "updatedAt": "2022-06-13T20:36:46Z",
      "closedAt": "2022-06-13T20:36:45Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "fixed by https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/60",
          "createdAt": "2022-06-13T20:36:45Z",
          "updatedAt": "2022-06-13T20:36:45Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOG6NyZs5I53sh",
      "title": "Add a section on recovery",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/26",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In general, retransmits for the frames with reliability in dropped packets on the multicast channels can happen on any channel that reaches the client, either over the unicast connection or the same or a different multicast channel.  Server has responsibility to give the client all the frames with reliability (any of the control frames, as well as STREAM frames).\r\n\r\nAlso possible to do a STREAM_RESET if a server gives up on some block of data.  When this happens, it's possible for the client to pick the stream up again later after a STREAM_BOUNDARY.\r\n\r\nA section covering this will probably also need to cover https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/16 (about how to handle limits on how much data server will buffer before abandoning a client that's not keeping up), so maybe these issues should be merged, or have different subsections.  But something reasonably complete is going to be needed on this topic.",
      "createdAt": "2022-05-02T17:14:11Z",
      "updatedAt": "2022-05-25T18:24:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "From discussion on 5/25:\r\n- probably we remove idle timeout and leave it to the server on when to leave\r\n- however, we still probably need a max ack delay\r\n- and we probably should specify that the first ack of data after joining a channel should be immediate, without any bundling or delay, to ensure server knows data is arriving for the channel",
          "createdAt": "2022-05-25T18:24:08Z",
          "updatedAt": "2022-05-25T18:24:08Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOG6NyZs5I6HBM",
      "title": "Frame spec cleanup",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/27",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "There's a number of problems with the frames:\r\n\r\n1. Channel IDs need a length preceding the 8..160.\r\n2. Some missing reasons in CLIENT_CHANNEL_STATE\r\n3. Better extensibility if we make the bit fields into varints and define their selector bits, I think.  Is this useful?\r\n\r\n(Note: working thru these in the course of frame implementation (https://github.com/GrumpyOldTroll/quiche/issues/5), proposal forthcoming...)\r\n\r\nFor point 3 I'm tentatively thinking something like this:\r\n\r\n~~~\r\n---\r\nMC_CLIENT_LIMITS Frame {\r\n  Type (i) = TBD-09 (experiments use 0xff3e809),\r\n  Client Limits Sequence Number (i),\r\n  Capabilities Flags(i),\r\n  Max Aggregate Rate (i),\r\n  Max Channel IDs (i),\r\n  Max Joined Count (i),\r\n}\r\n---\r\n{: #fig-mc-client-limits-format title=\"MC_CLIENT_LIMITS Frame Format\"}\r\n\r\nThe sequence number is implicitly 0 before the first MC_CLIENT_LIMITS frame from the client, and increases by 1 each new frame that's sent.\r\nNewer frames override older ones.\r\n\r\nLimit Support Flags is a bit field computed as follows:\r\n\r\n - 0x1 is set if IPv4 channels are permitted\r\n - 0x2 is set if IPv6 channels are permitted\r\n - 0x4 is set if SSM channels are permitted\r\n - 0x8 is set if ASM channels are permitted\r\n~~~\r\n\r\nPlus something similar in CHANNEL_PROPERTIES.  Nice part is this doesn't change encoding if we add flags that go beyond the reserved space, it just ends up taking more varint space when they're set.",
      "createdAt": "2022-05-02T18:17:27Z",
      "updatedAt": "2022-05-04T19:19:15Z",
      "closedAt": "2022-05-04T19:19:15Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess the same would also make sense in the transport property then. I am not sure what the trade-off between better extensibility and less available space is, a 1 byte sized var int only has 6 usable bits for example. I guess at the moment we still have 6 unused bits anyway so maybe there isn't much need for extensibility anyway?  \r\n\r\nIt would come down to 4 if you include the SSM/ASM selector though I still can't think of any cases where you would rather have ASM than SSM (this goes into #23). The server needs to know of all the senders anyway since it has to send the integrity frames for all streams, so it could just use multiple SSM joins for all the senders. Allowing ASM just seems like an enormous hassle and security vulnerability. I guess the use case would be somewhere within a domain where data might come from any number of senders, but again this wouldn't work as everything has to go through the server for the integrity frames. ",
          "createdAt": "2022-05-02T22:02:54Z",
          "updatedAt": "2022-05-02T22:05:29Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yeah, I'm not sure what the trade-off is either.  I found the WriteBytes function, so I guess I didn't really need to do this change, but now that it's done locally I'm not sure it's worth changing back, I think it's the same either way.\r\n\r\nRegarding ASM: The only interesting use case I know of is to allow P2P recovery between local neighbors.  As long as packets are unmodified by peers, they could still match a server's value for the integrity checks.  But you'd still need some kind of coordination.  NORM did this, and you could imagine something similar based on clients probing for others nearby, and sending each other NACKs when they think they missed data, but that would be another new thing beyond scope of the first version, and probably not worthwhile.\r\n\r\nSo yes, I think you're right it's probably more trouble than it's worth and we should probably just strip out ASM support as the best answer for #23.  I guess it leaves a couple extra unused bits for growth in a few spots, but mostly it prevents anyone from trying to use it, so we don't have to analyze how it could be used on purpose.  (However, some networks convert SSM membership reports to ASM on the network, so we still might need to talk about what kinds of problems are possible to see in the client, but I think this just falls under handling for spurious traffic--ignore if it's light and leave if it's heavy I think is the advice we probably want in the end.)",
          "createdAt": "2022-05-03T03:31:50Z",
          "updatedAt": "2022-05-03T03:31:50Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOG6NyZs5I6Luz",
      "title": "Remove STREAM_BOUNDARY",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/28",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "Good question on what this is and how it's meant to be used from Sam.  Rough answer I sent:\r\n\r\nIt's there because we have shared channels and they might carry streams, and it\u2019s useful to allow the streams to be long-lived.  It\u2019s possible (and I think useful) for a client to start processing an in-progress stream starting at the boundary of an HTTP push for instance, or at a message boundary for another higher-layer protocol, but without this stream boundary the client doesn\u2019t know at what byte offset inside the stream it\u2019s safe to start processing data (if a client started trying to parse the stream in the middle of the HTTP push, it wouldn\u2019t know how to interpret it).\r\n\r\nIn addition to h3 server push (and maybe webtransport?), I think this is useful for the latest moq-related proposals like RUSH (https://datatracker.ietf.org/doc/draft-kpugin-rush/) and WARP (https://datatracker.ietf.org/doc/draft-lcurley-warp/).\r\n",
      "createdAt": "2022-05-02T18:35:39Z",
      "updatedAt": "2022-05-18T22:10:32Z",
      "closedAt": "2022-05-18T22:10:32Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "On reflection, I think we should drop the STREAM_BOUNDARY.  I think it's either that or add a way to abandon old data on a stream prior to a boundary, but I think this is the same a just making a new stream.\r\n\r\nI think it means multicast will consume stream id space an order of magnitude faster than unicast, but that's probably ok, or if it's a problem it can be fixed with a later extension, but probably it's not a problem--stream id space for server-initiated streams would be 2^60-1 I believe, so at 20 streams per second (2 per ABR bit rate, one for the manifest and one for the segment) that would be 1.8 billion years by my calculations, or about 5 months to get to 8-byte stream ids instead of 4-byte stream ids.\r\n\r\nSo I'm changing the title and pulling out STREAM_BOUNDARY instead.\r\n",
          "createdAt": "2022-05-18T21:57:45Z",
          "updatedAt": "2022-05-18T21:57:45Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOG6NyZs5I69zO",
      "title": "Can the same stream ID be used in multiple channels?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/29",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since the stream ID space is shared between all channels and the connection, would it be possible for two channels to send data on the same stream? \r\n\r\n4.4 says:\r\n`a server can always avoid stream ID collisions with the stream IDs carried in sessions`\r\nDoes this mean it MUST avoid collisions? \r\n\r\nI guess it depends on where the stream data is processed, if there is a sub process for each channel it might be ok, but if they all end up in the same place you would presumably see different packets with the same ACK number (since each channel uses its own ACK number space, so they have to overlap), which would probably lead to issues.\r\n\r\nIn either case I think it is something that should be clarified. \r\n\r\n",
      "createdAt": "2022-05-02T22:15:35Z",
      "updatedAt": "2022-05-18T23:20:01Z",
      "closedAt": "2022-05-18T23:20:01Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, probably something should be clarified.\r\n\r\nA rough answer to your questions:\r\nStream frames for the same stream can appear on different channels, yes.\r\n\r\nHowever, all stream frames for the same stream still have to represent data from a single continuous stream of bytes, such that data at the same offset is identical regardless of what path a stream frame arrived on.  So for example, as explained in [2.2 of 9000](https://www.rfc-editor.org/rfc/rfc9000#section-2.2), \"The data at a given offset MUST NOT change if it is sent multiple times; an endpoint MAY treat receipt of different data at the same offset within a stream as a connection error of type PROTOCOL_VIOLATION\".\r\n\r\nYou could send a frame with bytes 0-15 for stream 3 on channel 1, and then send a frame with bytes 16-30 for stream 3 on channel 2, then send a frame with bytes 10-25 over unicast.  While probably inefficient, this would all be correct behavior that can be properly interpreted by the client as long as the byte at each offset of that stream is the same no matter where it came from.\r\n\r\nThe more likely real scenario is recovery.  You send a packet 14 on channel 1 and it contains bytes 50-100 of stream 3, but the MP_CHANNEL_ACKS the server sees suggest the packet has probably been lost.  Server then sends packet 70 on its unicast channel, and it contains a copy of the frame that was lost in packet 14 of channel 1, thus filling in the missing data.  If packet 70 is lost as well, maybe later it'll send packet 80 with another copy of the same frame (or maybe it'll break up the frame into smaller pieces, which is fine as long as each byte at each offet is still the same.)\r\n\r\nIt doesn't matter for the stream that there's different packet number spaces.  The server is responsible for knowing what stream frames the receiver has received on each path according to the acks (and what the contents of those frames were, so it can retransmit).  As an optimization, the collection of servers using the same channel might also notice that many receivers on the same channel lost the same packet, and you might send a new packet on that channel containing the frames that need retransmitting, rather than using unicast for the recovery.",
          "createdAt": "2022-05-03T02:49:16Z",
          "updatedAt": "2022-05-03T02:49:16Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "The comment about stream ID collisions is maybe a mistake.  It's ok to coordinate sending of stream data on different channels, provided it's the same stream data.  What's not ok is if the different channels each think they're independently in charge of the data that goes out in a particular stream id, and therefore produce different data for the stream at any of the same offsets.  \"Collision\" is probably too ambiguous a term there, sorry for the confusion.",
          "createdAt": "2022-05-03T02:51:24Z",
          "updatedAt": "2022-05-03T02:51:24Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "As a matter of operational practice, the way I imagine actually running is that there's one thing generating the stream, and the stream data might be mirrored on a few channels (for instance, an ipv4 and an ipv6 channel, or maybe channels with different encryption algorithms, in order to support different sets of receivers with different capabilities).  The IPv4 channel will probably break the stream up into frames at different offsets from the IPv6 channel, because they'll have different packet payload sizes.  This is ok, provided that they carry the same sequence of data.\r\n\r\nA receiver might leave one network and join another network, and as a result might switch (at server's direction, after passing new client limits derived from its network change) from the ip4 channel to the ip6 channel.  Maybe it misses a few packets, which the server notices via the mp_channel_acks, so server fills in the missing stream data with unicast-transmitted data of the same stream (this might or might not have offset boundaries for the frames that get generated that are different from the channels' frame boundaries).  Although each of these paths has a different packet number space, since they're all using the same stream id and the data at each offset in the stream id is the same no matter where it came from, they can always avoid confusion.\r\n\r\nThis kind of stream handling is all the same as in multipath and connection migration, I believe.  It doesn't matter what packet number space stream data arrived on for the client, just the stream id and the offset.\r\n\r\nThe packet number space is what gets acked, so the server has to keep track of which frames were in which packets so it can retransmit frames with the stream data that the client is still missing.  (It doesn't have to be the same frames, it just has to carry the same data.  2 frames from 50-100 and 101-150 is the same as 1 frame from 50-150, is the same as 3 frames from 50-75, 76-125, and 126-150, as long as they're the same stream id and the byte at every offset is the same.)",
          "createdAt": "2022-05-03T03:11:35Z",
          "updatedAt": "2022-05-03T03:11:35Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOG6NyZs5JA_gF",
      "title": "MC_CHANNEL_LEAVE text incomplete",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/32",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Write something more coherent for the MC_CHANNEL_LEAVE text.",
      "createdAt": "2022-05-04T07:08:10Z",
      "updatedAt": "2022-05-18T23:08:19Z",
      "closedAt": "2022-05-18T23:08:19Z",
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDOG6NyZs5JCOgU",
      "title": "Initial timeout",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/33",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "The initial time to join a channel can be significantly longer than the value in max idle time (as that is intended as the time to detect a disruption of an already established channel) as the join has to be propagated and the multicast tree constructed. \r\n\r\nThere could probably be an additional field in MC_CHANNEL_PROPERTIES (something like max establishment time) or just general guidance and a recommendation on the time it might take. ",
      "createdAt": "2022-05-04T12:45:17Z",
      "updatedAt": "2022-05-27T15:49:50Z",
      "closedAt": "2022-05-27T15:49:50Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, I wasn't sure whether this belongs in MC_CHANNEL_PROPERTIES or whether it should just be documented as a client-side configuration parameter that doesn't appear on the wire.  We certainly need to say something about it, but I'm not sure server-driven properties is the right place to put it because it's more dependent on what typically works for the receive network than on a common characteristic of the server.\r\nThe way I think of it, there's some kind of \"expected join time\" in the client network (which might be unknown and needs a reasonable default), and this should be added to the max_idle_time before sending a leave due to lack of traffic.\r\n\r\nMaybe another reason for the leave would be good to add as well to indicate \"never got any data\" that's different from \"Max Idle Time Exceeded\".",
          "createdAt": "2022-05-04T16:12:56Z",
          "updatedAt": "2022-05-04T16:12:56Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOG6NyZs5JCQ-c",
      "title": "AMT",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/34",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "This might be too much for the initial document and could be an expansion, but it might be useful to add a frame that contains information about available AMT relays for the channel in question. That way you could still distribute load better in cases where e2e native multicast isn't supported by utilizing as much multicast as possible (up until the relays) and reduce the load on the server by having many unicast connections. \r\n\r\nI guess this idea similar to having a fan out, but it might be an interesting alternative. You might even be able to do something clever by determining which relay is best suited by the clients IP or something along those lines and then just including that. \r\n\r\nI guess in theory this could be done by simply adding an AMT relay field to the MC_CHANNEL_PROPERTIES.",
      "createdAt": "2022-05-04T12:54:37Z",
      "updatedAt": "2022-05-04T18:50:06Z",
      "closedAt": "2022-05-04T17:31:25Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think this is just worse for network offload than sending the data on the unicast channel?\r\n\r\n(It adds a bit of AMT overhead, but since the gateway is embedded in the client and talking to a server-chosen relay it definitely didn't use any network replication except in the server-controlled part of the network.)",
          "createdAt": "2022-05-04T16:19:24Z",
          "updatedAt": "2022-05-04T16:19:24Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I was thinking that you might at some point get ISP/ operator provided relays close to the edge like Lenny (I think?)  suggests. I guess there is a bit missing that would allow these relays to announce themselves to the server. In either case, it should not be part of the base spec so I am gonna move this issue to my fork just so its written down somewhere. ",
          "createdAt": "2022-05-04T17:30:19Z",
          "updatedAt": "2022-05-04T17:30:19Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "ISP/operator-run relays wouldn't be something the server could transmit in its channel properties.  That *could* happen, yes, and it *could* usefully be integrated with receive libraries, but it would be an integration with how to do local discovery of relays, not a server advertisement feature.\r\n\r\nI think this is plausible for instance with DNS-SD using a local search domain, which is why I put that discovery path in RFC 8777 at higher priority than the actual driad extension, but for the same reason it's not under the source ip's reverse ip dns space, it also can't be in the server-sent channel properties.  It would have to be a separate thing in the browser that's about local service discovery, so I think it's a separate thing from this spec.",
          "createdAt": "2022-05-04T18:50:06Z",
          "updatedAt": "2022-05-04T18:50:06Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOG6NyZs5JETx2",
      "title": "Loss of a MC_CHANNEL_PROPERTIES frame (and potentially MC_CHANNEL_LEAVE)",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/35",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If sent over multicast, a MC_CHANNEL_PROPERTIES frame might get lost. Add text that states that servers MUST retransmit frames lost this way over unicast.\r\n\r\nIf the split into multiple frames happens, this would probably be only a MUST for the key update frames. ",
      "createdAt": "2022-05-04T20:03:08Z",
      "updatedAt": "2022-05-18T23:09:18Z",
      "closedAt": "2022-05-18T23:09:18Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Why?  I think it's just up the server like anything else it wants to send on how's the best way?\r\n\r\nBoth unicast and multicast have cases where the client doesn't get the update before the Until Packet Number runs out, but then the client just leaves until further notice from the server, I think.  Is there some reason that's not a good enough fallback for this case?",
          "createdAt": "2022-05-05T04:05:43Z",
          "updatedAt": "2022-05-05T04:05:43Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Well I was thinking more along the lines that the client misses a key change (that may or may not occur before the previously stated until_packet) and then suddenly can no longer verify the integrity of the multicasted frames.\r\n\r\nBut you\u2019re right, MUST is too strong here. I just thought it would be good to make it clear that this is something that might happen and will in most cases probably not be what the server intents. So maybe a SHOULD? ",
          "createdAt": "2022-05-05T15:55:48Z",
          "updatedAt": "2022-05-05T15:55:48Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Key change means they can no longer decrypt, but yes, same if they miss a hash algorithm change.\r\n\r\nI agree server has to cause a retransmit that client can receive and interpret in a reasonable amount of time, but I think it could for instance be sent on a different multicast channel rather than the unicast channel (and any channel that's broken or left by a client won't work, including the channel that just got updated and client missed it) but I'm not seeing how there's inherently a unicast-specific requirement as opposed to any path that's still working even if the frame in question got lost.\r\n\r\nMaybe it could be right to have a paragraph pointing out that when some updates are missed it makes the channel broken, so server shouldn't use it for retransmitting.",
          "createdAt": "2022-05-05T16:20:15Z",
          "updatedAt": "2022-05-05T16:20:15Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I'm not actually sure we need any text for this specifically, as opposed to just actually writing the recovery section (#26), so maybe we should close this one as a dup?",
          "createdAt": "2022-05-18T22:54:45Z",
          "updatedAt": "2022-05-18T22:54:45Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, makes sense I guess ",
          "createdAt": "2022-05-18T23:09:18Z",
          "updatedAt": "2022-05-18T23:09:18Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOG6NyZs5JEVYp",
      "title": "Be consistent about saying if frames are sent on channels or connections",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/36",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Most frames just state that they are sent \"From server to client\" while e.g. MC_SESSION_LEAVE says \"from server to client\r\nin either the unicast connection or a channel\"\r\n\r\nEither remove the specifier from everywhere or, and probably better, add it to everywhere. ",
      "createdAt": "2022-05-04T20:06:22Z",
      "updatedAt": "2022-05-18T23:08:13Z",
      "closedAt": "2022-05-18T23:08:13Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think removing it here and just using the list at the bottom as the only normative reference for what frames can be sent over which transmit options will make it easier to keep straight.",
          "createdAt": "2022-05-05T04:06:53Z",
          "updatedAt": "2022-05-05T04:06:53Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOG6NyZs5KB4wm",
      "title": "move aead algorithm to CHANNEL_ANNOUNCE",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/42",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Suggested change from @squarooticus :\r\n\r\nAnnounce the payload AEAD algorithm in CHANNEL_ANNOUNCE and just assume it isn't going to change for the lifetime of the channel. This probably works better with existing QUIC stacks that assume only the key, rather than the alg, will change during a connection.",
      "createdAt": "2022-05-19T16:09:52Z",
      "updatedAt": "2022-10-11T08:35:31Z",
      "closedAt": "2022-05-23T13:36:38Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Would maybe also make sense for the hash algorithm? ",
          "createdAt": "2022-05-19T16:53:11Z",
          "updatedAt": "2022-05-19T16:53:11Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I definitely mean both.",
          "createdAt": "2022-05-19T17:01:47Z",
          "updatedAt": "2022-05-19T17:01:47Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #55 ",
          "createdAt": "2022-05-25T17:00:37Z",
          "updatedAt": "2022-05-25T17:00:37Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. I definitely mean both.\n\n\nOn Thu, May 19, 2022 at 12:53 PM Max Franke ***@***.***>\nwrote:\n\n> Would maybe also make sense for the hash algorithm?\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/42#issuecomment-1131955892>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAYF7R4JYEW45O3B3ALAC5DVKZWYJANCNFSM5WMXL55A>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***\n> com>\n>\n",
          "createdAt": "2022-10-11T08:35:30Z",
          "updatedAt": "2022-10-11T08:35:30Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOG6NyZs5KB8Og",
      "title": "Michaels review - Give more details about the unicast connection ",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/43",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "> I have a feeling that more should be said about this unicast connection. Some constraints perhaps\u2026 can it migrate? Can it use multiple streams? Can it be used for traffic that\u2019s not bound to the signaling for the multicast stuff here?\r\n> \r\n> Also: here, and in most places, you call it \u201cthe unicast connection\u201d, which makes quite clear that there is one only. That\u2019s good!  But in some places, it says \u201ca unicast connection\u201d which then confuses me. There IS only one which is associated with this multicast stuff, right?\r\n\r\n",
      "createdAt": "2022-05-19T16:22:47Z",
      "updatedAt": "2022-06-13T20:38:59Z",
      "closedAt": "2022-06-13T20:38:59Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "There is only one, yes.  I agree, \"a unicast connection\" should be changed to \"the unicast connection\".\r\n\r\nI think there are no restrictions on the unicast connection.  It can migrate, it can use multiple streams, it can be used for traffic not bound to the signaling for the multicast stuff.  It can be multipath.\r\n\r\nThe only restriction I know that seems like it has been confusing is the restriction on streams: any byte of data at any offset of a particular stream must be the same no matter where the frame containing that byte of stream data came from.  \r\n\r\nThis might place some operational restrictions on servers that use the same channels, to make sure they individually don't generate any unicast streams that could conflict.  (I think they have several mechanisms they can use to ensure that doesn't happen, but I think it's implementation-specific.)",
          "createdAt": "2022-05-19T17:42:03Z",
          "updatedAt": "2022-05-19T17:42:03Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #60 ",
          "createdAt": "2022-06-13T20:38:59Z",
          "updatedAt": "2022-06-13T20:38:59Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOG6NyZs5KB8_2",
      "title": "Michaels review - Add text for graceful degradation",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/44",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding graceful degradation to unicast: \r\n> I\u2019d expect this spec to tell me how... but maybe in a future version.",
      "createdAt": "2022-05-19T16:25:47Z",
      "updatedAt": "2022-05-25T18:48:04Z",
      "closedAt": "2022-05-25T18:48:04Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Now part of #61 ",
          "createdAt": "2022-05-25T18:48:01Z",
          "updatedAt": "2022-05-25T18:48:01Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOG6NyZs5KB_3o",
      "title": "Michaels review - Rephrase part of section 11.2",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/45",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Regarding this part:\r\n\r\n> From Packet Number and Until Packet Number are used to indicate the packet number (Section 17.1 of [[RFC9000](https://www.ietf.org/archive/id/draft-jholland-quic-multicast-00.html#RFC9000)]) of the 1-RTT packets received over which these values are applicable.\r\n\r\nHis comment is:\r\n\r\n> This is hard to understand, and I think it\u2019s to do with \u201cthese values\u201d. Replace with \u201cthe fields of the MC_CHANNEL_PROPERTIES frame\u201d, perhaps??",
      "createdAt": "2022-05-19T16:36:55Z",
      "updatedAt": "2022-06-13T20:39:13Z",
      "closedAt": "2022-06-13T20:39:13Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #60 ",
          "createdAt": "2022-06-13T20:39:13Z",
          "updatedAt": "2022-06-13T20:39:13Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOG6NyZs5KCAHF",
      "title": "Michaels review - \"unspecified termination\"",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/46",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Regarding this part:\r\n\r\n> A From Packet Number without an Until Packet Number has an unspecified termination.\r\n\r\nHis comment is:\r\n\r\n> That also reads strange to me. Why not just say \u201cis not specified\u201d ",
      "createdAt": "2022-05-19T16:37:44Z",
      "updatedAt": "2022-06-13T15:31:39Z",
      "closedAt": "2022-06-13T15:31:39Z",
      "comments": []
    },
    {
      "number": 48,
      "id": "I_kwDOG6NyZs5KDCX7",
      "title": "MC_CHANNEL_INTEGRITY frames MUST be protected against injection, modification, and repla",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/48",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll",
        "squarooticus"
      ],
      "labels": [],
      "body": "\"Integrity\" as defined in draft-krose-multicast-security is specific to multicast (and necessarily weaker than for unicast). So I think the use of \"integrity\" in normative language here is probably ambiguous. The key properties are protection against:\r\n\r\n* Injection: an attacker, including other receivers, must not be able to create new channel integrity frames that will be accepted by a properly-functioning receiver. \r\n* Modification: an attacker, including other receivers, must not be able to modify channel integrity frames such that they will be accepted by a properly-functioning receiver.\r\n* Replay: an attacker, including other receivers, must not be able to alter the content delivered to a receiver through the replay of previously-seen channel integrity frames.\r\n\r\nRight now, all three properties are achieved by sending (and presumably accepting) such frames only over unicast QUIC. In the future, the first two properties will be provided by something like AMBI-over-unicast-or-signed-manifest or ALTA, while the third is (now and in the future) provided by the fact that channel integrity frames are stateless and declarative (i.e., a given frame has an immutable meaning).",
      "createdAt": "2022-05-19T20:47:11Z",
      "updatedAt": "2022-06-21T22:00:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I should emphasize that until we have out-of-band integrity, any channel integrity packets received over multicast MUST be dropped. We could track the provenance of QUIC packets throughout the stack, or drop such privileged frames before they are injected into whatever packet queue exists in the code (if any; I don't know quite how that works yet). But I do find the way it is designed elegant in the sense that adding OOB integrity protection requires no changes to the QUIC frames as-defined here, only to how they are authenticated and interpreted.",
          "createdAt": "2022-05-19T20:53:26Z",
          "updatedAt": "2022-05-19T20:54:52Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I don't follow. The current intent is that if an integrity frame is received in a packet delivered with a multicast channel, it is accepted only if the packet containing the frame has a hash in another integrity frame that was accepted.  So they can be accepted over either unicast or multicast.\r\n\r\nAs a practical matter, I agree there has to be be a unicast anchor, but a packet with its integrity guaranteed by a prior integrity frame can contain more integrity frames, and this provides transitive integrity much like a Merkle tree, doesn't it?",
          "createdAt": "2022-05-20T05:50:03Z",
          "updatedAt": "2022-05-20T05:50:03Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "That said, +1 to making a solid definition of the properties that are provided by the integrity frames, that's a great insight.  But I think the properties provided are for QUIC packets delivered over multicast channels.  This provides (I think?) the same 3 properties for whatever frames are carried within those packets, right?",
          "createdAt": "2022-05-20T05:55:21Z",
          "updatedAt": "2022-05-20T05:55:21Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't follow. The current intent is that if an integrity frame is received in a packet delivered with a multicast channel, it is accepted only if the packet containing the frame has a hash in another integrity frame that was accepted. So they can be accepted over either unicast or multicast.\r\n\r\nWell, it's more complicated, right? It's either a hash in another accepted integrity frame, or it's delivered over unicast (which has QUIC-native integrity guarantees). It's the principle that every integrity frame must be cryptographically linked to an established root of trust.",
          "createdAt": "2022-05-20T15:32:24Z",
          "updatedAt": "2022-05-20T15:32:24Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "So, scratch my objection to multicast-delivered integrity frames. Instead: ideally, the draft would specify a necessary and sufficient set of conditions for an integrity frame to be accepted that will not require updating when AMBI or ALTA are introduced.",
          "createdAt": "2022-05-20T15:34:05Z",
          "updatedAt": "2022-05-20T15:34:05Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think we can close this, right?  Or @squarooticus did you have some text you wanted to put in about this to try to phrase it so AMBI can be used without making it confusing?",
          "createdAt": "2022-06-21T00:41:03Z",
          "updatedAt": "2022-06-21T00:41:03Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have text yet, but I would like to write some. Can we keep this open until I have a chance to look at it?",
          "createdAt": "2022-06-21T02:45:44Z",
          "updatedAt": "2022-06-21T02:45:44Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "If you make me a contributor, I can assign it to myself.",
          "createdAt": "2022-06-21T02:46:41Z",
          "updatedAt": "2022-06-21T02:46:41Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "I_kwDOG6NyZs5KIoqq",
      "title": "Add channel state diagrams",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/50",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "We at least need a channel state diagram for client, and probably also for server.\r\n(like https://www.rfc-editor.org/rfc/rfc9000#fig-stream-send-states and https://www.rfc-editor.org/rfc/rfc9000#fig-stream-recv-states and https://www.ietf.org/archive/id/draft-ietf-quic-multipath-01.html#fig-path-states)",
      "createdAt": "2022-05-20T23:17:18Z",
      "updatedAt": "2022-05-27T15:40:50Z",
      "closedAt": "2022-05-27T15:40:50Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, I was thinking about states when I made the object as well. So far I have 4 (Idle, joining, joined and timed out). Do you think we need more?",
          "createdAt": "2022-05-21T21:37:54Z",
          "updatedAt": "2022-05-21T21:37:54Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think I was thinking different names for them in the client, but maybe :\r\n - unjoined\r\n - attempting join (joined and MC_CLIENT_CHANNEL_STATE: Joined sent, but no data received yet)\r\n - joined (data received and MC_CHANNEL_ACK sent)\r\n - held down (timer or status prevents joining--generally should go here after an error but not a clean leave)\r\n\r\nFor the server side I was thinking:\r\n - client unjoined\r\n - client pending join (sent a MC_CHANNEL_JOIN, no MC_CLIENT_CHANNEL_STATE received yet)\r\n - client joined (MC_CLIENT_CHANNEL_STATE with Joined received)\r\n - client pending leave\r\n - client held down (unjoined and server will not currently retry join due to prior error)\r\n\r\nI wasn't sure whether we need a \"client confirmed\" state where we've seen an ack of channel data on the server, I'm ambivalent on it.\r\n\r\nI think it might also be useful to define some hold-down conditions and timers, which I don't think we've gotten into yet.  We probably need a retry section and some general advice about how to handle error-based leave/decline events that hold down a retry for some time, maybe a growing time.",
          "createdAt": "2022-05-22T02:00:52Z",
          "updatedAt": "2022-05-22T02:00:52Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOG6NyZs5KIqL_",
      "title": "Add flow diagrams",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/51",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Flow diagrams like these should show the important parts for channel use examples and who they're sent by:\r\n- https://www.rfc-editor.org/rfc/rfc9000#fig-auth-cid\r\n- https://www.rfc-editor.org/rfc/rfc9000#figure-5\r\n",
      "createdAt": "2022-05-20T23:23:42Z",
      "updatedAt": "2022-06-08T18:28:45Z",
      "closedAt": "2022-06-08T18:28:45Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "I_kwDOG6NyZs5KI8BC",
      "title": "Encrypt-then-mac is recommended",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/52",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "From @squarooticus:\r\n\u00a7 7.1 is going to trigger some folks who have ETM (encrypt-then-mac) on the brain to avoid leaking information, so some reassurance that the packet hashes are in the encrypted stream would probably suffice to prevent this reaction.\r\n\r\nResponse from Jake:\r\n\r\nI guess the flow here if the hash is on the encrypted packet is:\r\n 1. hash the packet with the channel's hash algorithm\r\n 2. decrypt the packet (or at least the header) so you have the packet number\r\n 3. check the hash, reject if it doesn't match\r\n 4. parse the packet and accept it (provided it doesn't trigger protocol errors, etc.)\r\n \r\nWould that work better?",
      "createdAt": "2022-05-21T03:47:52Z",
      "updatedAt": "2022-06-21T21:59:29Z",
      "closedAt": "2022-06-21T21:59:29Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOG6NyZs5KI88V",
      "title": "MC_CHANNEL_ACK needs ECN/non-ECN versions, like other acks",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/53",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-21T04:06:36Z",
      "updatedAt": "2022-05-25T17:00:20Z",
      "closedAt": "2022-05-25T16:59:59Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #54 ",
          "createdAt": "2022-05-25T17:00:20Z",
          "updatedAt": "2022-05-25T17:00:20Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOG6NyZs5KPE26",
      "title": "Retiring a channel",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/58",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Two things that might need clarification:\r\n\r\n- Retiring a channel that is currently joined should probably force an automatic leave\r\n-  Should there be a Retired option for the MC_CHANNEL_STATE frame so the server knows if a channel was retired successfully? ",
      "createdAt": "2022-05-23T17:03:10Z",
      "updatedAt": "2022-05-27T15:50:42Z",
      "closedAt": "2022-05-27T15:50:42Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Discussion landed on: we should add a Retired state to the MC_CHANNEL_CLIENT_STATE frame, and we should send it from client when we see a MC_CHANNEL_RETIRE.  Server cannot announce a new channel reusing that id if it has previously sent an ANNOUNCE and has not yet seen a Retire in a MC_CHANNEL_CLIENT_STATE frame.",
          "createdAt": "2022-05-25T18:45:11Z",
          "updatedAt": "2022-05-25T18:45:11Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOG6NyZs5Kas6u",
      "title": "Add operational considerations section",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/61",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depending on size might also be a separate ID.\r\n- Include reference to CBACC\r\n- Include fan out/ deployment strategies\r\n- Graceful degradation (#44)\r\n- Pool/ Channel management on the server side\r\n- Reusing the same S,G for multiple channels might have implications for the rate on the network\r\n- ...",
      "createdAt": "2022-05-25T18:28:29Z",
      "updatedAt": "2022-06-21T21:59:16Z",
      "closedAt": "2022-06-21T21:59:16Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Reference to CBACC should also mention that popularity-based metrics within a multicast network imply that clients SHOULD NOT leave just because they are not receiving traffic, if they are otherwise willing to receive multicast and server has asked them to try (also the reason behind fixing #63).",
          "createdAt": "2022-06-20T21:29:47Z",
          "updatedAt": "2022-06-20T21:29:47Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOG6NyZs5Kj3Vl",
      "title": "Make at least one server-side state diagram",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/62",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "possibly we need 2, there's a global state of channel existence, plus a client-specific state of joined/left.  But maybe it can fit in one diagram, not sure yet.",
      "createdAt": "2022-05-27T15:51:26Z",
      "updatedAt": "2022-06-20T22:26:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Proposed diagram (to be converted to text):\r\n![Channel State Diagram (server)](https://user-images.githubusercontent.com/361578/174684311-b13b689e-d322-479a-9554-0504ed0b11be.svg)\r\n\r\nSee also source at:\r\nhttps://docs.google.com/presentation/d/1J1ISZFYUT-9nxX7vq17oNKAtDXZYv6KrXH4Y6AtiLSM/edit#slide=id.p\r\n",
          "createdAt": "2022-06-20T22:24:55Z",
          "updatedAt": "2022-06-20T22:24:55Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "(Note that svgs can be included in RFCs, but should also provide a text mapping: https://datatracker.ietf.org/doc/html/rfc7996)",
          "createdAt": "2022-06-20T22:26:52Z",
          "updatedAt": "2022-06-20T22:26:52Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOG6NyZs5LIGfk",
      "title": "Replace Max Idle Time with Max Ack Delay",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/63",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think we talked about this but forgot the issue I think:\r\n\r\nSince the server knows if/ when reception of multicast is interrupted (by no longer getting ACKs) there is no need for clients to leave channels unilaterally if they think the channel timed out. ",
      "createdAt": "2022-06-03T21:44:41Z",
      "updatedAt": "2022-06-21T01:51:31Z",
      "closedAt": "2022-06-21T01:51:31Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yeah, and ideally they should not do so, to allow popularity analysis to work correctly inside the ISP.  I think this point probably deserves a mention in the operational considerations section (#61)\r\n(Clients can still leave for other reasons as desired but should not leave due to non-receiving.)",
          "createdAt": "2022-06-20T21:26:39Z",
          "updatedAt": "2022-06-20T21:26:39Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "There's already a max_ack_delay transport parameter in base quic (https://www.rfc-editor.org/rfc/rfc9000#section-18.2), is there any reason we can't just use that and leave this out?",
          "createdAt": "2022-06-20T21:33:58Z",
          "updatedAt": "2022-06-20T21:33:58Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I remember now--I think we said there should be a different value that was per-channel, basically to allow for more aggregation especially on slower channels (and especially considering the linear ack scaling problems).\r\n\r\nBut I think we probably don't need the Bundle Size anymore if we take out the idle time, it can just fit in the per-channel max_ack_delay, right?",
          "createdAt": "2022-06-20T21:43:55Z",
          "updatedAt": "2022-06-20T21:43:55Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOG6NyZs5LaMW-",
      "title": "Ordering of Announce, properties and Join",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/64",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Client's have no way to communicate to the server if a properties frame arrives after an announce frame. In this case, it might take them until they receive a join for the server to notice that the properties are missing. ",
      "createdAt": "2022-06-08T18:50:37Z",
      "updatedAt": "2022-06-21T22:00:17Z",
      "closedAt": "2022-06-21T22:00:17Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Solution: Have announce frame include all properties as well, remove all properties except key from properties frame making it exclusively for key updates. Add text that when there are significant changes to any of the (now immutable) properties, a new channel should be created instead of updating the old one. ",
          "createdAt": "2022-06-08T22:22:13Z",
          "updatedAt": "2022-06-08T22:22:13Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "There's a related race condition in properties frames themselves:\r\n\r\n> Properties Sequence Number: Increases by 1 each time the properties for the channel are changed by the server. The client tracks the sequence number of the MC_CHANNEL_PROPERTIES frame that set its current value, and only updates the value and the packet number range on which it's applicable if the Properties Sequence Number is higher.\r\n\r\nIf two are intentionally sent in sequence but the second is received and processed first, the first will never be processed and packets in that range may not be decryptable.",
          "createdAt": "2022-06-10T18:57:58Z",
          "updatedAt": "2022-06-10T18:57:58Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "How about we say say there can\u2019t be any gaps in the sequence numbers then the client would one is missing and could either buffer the higher one until it is received or retroactively apply the key of the lower one once it arrives.",
          "createdAt": "2022-06-10T20:51:18Z",
          "updatedAt": "2022-06-10T20:51:18Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "\"No gaps\" I think is probably stronger than ideal since it means you can't update over multicast anymore, since a later joiner would need to start at 1.\r\n\r\nSeems to me there's a few properties we might need to talk a little more about:\r\n- the From Packet Number increases with increasing MC_CHANNEL_KEY sequence numbers (the new name for MC_CHANNEL_PROPERTIES).  Maybe client can PROTOCOL_ERROR if not?  I think this gives you an unambiguous decryption key whenever you know you do not have a gap in sequence numbers, and some uncertainty for any packet later than the latest From Packet Number you've seen (in the case that you've missed a MC_CHANNEL_KEY frame) or any space where there's a gap in the sequence numbers.\r\n  - This uncertainty means there are cases you might fail decode due to wrong key if there's a missing update.\r\n- you MUST discard sufficiently old keys, just like for forward secrecy in unicast.  I think probably if you've received all packets up to the next From Packet number, but even if you haven't received them you still discard after a long enough duration (30s?  I dunno...) after receiving a new key frame.  But for old keys, we know when they stopped being valid, so we can keep a packet number before which we should not attempt decodes if we see an old packet.  (Do we need that in the JOIN or the ANNOUNCE or something?)\r\n\r\nAnyway, I'm a little worried now that I think of it we might currently have ambiguity on knowing whether or not we have a key that applies to a particular packet.  Is it harmless (outside of wasted processing) to decode a packet with the wrong key and then discard it due to failed decode, or do we need stronger non-ambiguity?\r\n\r\nNote also that if necessary we could use key phase to notice if we're decoding a packet for which we missed a key update as long as it's not a gap more than 2, which would help a bunch with the ambiguity problem.",
          "createdAt": "2022-06-13T21:26:59Z",
          "updatedAt": "2022-06-13T21:26:59Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I think using the key phase (in the packet header) is actually a very good idea. I don\u2019t think we would even need it in the key frame as the client just needs to know that when it flips there is a new key that is should use and if it doesn\u2019t have one it probably missed a key update. \r\nI am not sure how useful/necessary it is to send the key updates over Multicast now that the frame is so small, the trade off would be to save performance but having strict key sequence numbers without gaps. Also I guess Even if they are send over Multicast they could still be without gaps, new clients would just get an initial sequence number that is larger than 1. ",
          "createdAt": "2022-06-13T21:59:11Z",
          "updatedAt": "2022-06-13T21:59:11Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Current proposal is:\r\n- take the secret out of MC_ANNOUNCE and recommend not sending MC_KEY except to clients that will also get a MC_JOIN (just to reduce scope of key distribution to only those who need it)\r\n- receiving a MC_KEY or a MC_ANNOUNCE will create the channel at client.  Keys should be stored even for a channel without properties, with a buffer size limit of 2 (with a MUST discard old keys like in TLS to have forward secrecy in compliant clients. Client MAY hold up to 2 at a time and SHOULD discard the older one after some time like 3-10s of non-receipt of older packets)\r\n- A join without both MC_KEY and MC_ANNOUNCE previously received will get a Declined Join(Unsynchronized Properties).\r\n- However, this is a transient state since both MC_KEY and MC_ANNOUNCE will be eventually received after recovery.  Join can be safely retried\r\n- (maybe recommend if a retry was necessary wait until both were acked, but not sure it's needed?)\r\n\r\nI'll update the text and make a PR if there's no objections to this?",
          "createdAt": "2022-06-20T21:23:05Z",
          "updatedAt": "2022-06-20T21:23:05Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "If a client received an announce but not yet a key, maybe instead of retrying the join later it should just \"join\" (send IGMP/MLD report) the channel already? It has all the necessary information, just can't decrypt the stream frames. But I *think* in most cases a lost key would be retransmitted long before the client actually manages to receive any multicast packets anyway, so it might be a good optimization (Could also be left out for now).\r\n\r\nAlso, I can't think of any right now but there might be some implications or trickiness with the state sequence numbers (which the server needs to use in join/leave/retire packets) if the client just retries a join on its own without being told so by the server (just something to keep in mind I guess). \r\n\r\nBut other than those two things this sounds like a good proposal, thanks. ",
          "createdAt": "2022-06-20T23:30:23Z",
          "updatedAt": "2022-06-20T23:31:01Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I should clarify my meaning: the Join cannot be retried by the client unilaterally after sending an MC_STATE(Declined Join).  When I said the join could be retried, I meant the server can send a new MC_JOIN once it sees that the client has acked both the MC_KEY and the MC_ANNOUNCE.",
          "createdAt": "2022-06-21T09:20:32Z",
          "updatedAt": "2022-06-21T09:20:32Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I don't think it's a good assumption that the multicast data will be slow to arrive.  For the first to join it's slow, but for others who join from the same network it will be fast, and for the popular events that will use multicast the most widely, this would be the most common case.  I think you're right for testing and small events, but large events will typically differ there.",
          "createdAt": "2022-06-21T09:23:27Z",
          "updatedAt": "2022-06-21T09:23:27Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOG6NyZs5LbBLy",
      "title": "Move everything other than key to Announce frame",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/65",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-08T22:20:55Z",
      "updatedAt": "2022-06-08T22:21:07Z",
      "closedAt": "2022-06-08T22:21:07Z",
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDOG6NyZs5LsYKz",
      "title": "remove MC_PATH_RESPONSE",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/67",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We don't need the PATH_CHALLENGE/MC_PATH_RESPONSE logic, I think.  We're anchored by the unicast connection, and we get acks for received packets.",
      "createdAt": "2022-06-13T20:33:41Z",
      "updatedAt": "2022-06-13T20:38:37Z",
      "closedAt": "2022-06-13T20:38:37Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #68 ",
          "createdAt": "2022-06-13T20:38:37Z",
          "updatedAt": "2022-06-13T20:38:37Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOG6NyZs5MI2WQ",
      "title": "Frame names too long, diagrams too wide",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/69",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "Warnings during build about idnits violations from diagram width (both).  In large part driven by frame name length.",
      "createdAt": "2022-06-20T21:07:49Z",
      "updatedAt": "2022-06-21T03:42:45Z",
      "closedAt": "2022-06-21T03:42:45Z",
      "comments": []
    },
    {
      "number": 72,
      "id": "I_kwDOG6NyZs5MJa9-",
      "title": "clarify how the secret in the MC_KEY frame is used",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/72",
      "state": "CLOSED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-21T00:42:15Z",
      "updatedAt": "2022-06-21T21:59:42Z",
      "closedAt": "2022-06-21T21:59:42Z",
      "comments": []
    },
    {
      "number": 75,
      "id": "I_kwDOG6NyZs5MZs3I",
      "title": "Add an Application use cases sub-section?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/75",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I thought I'd capture here some iffy text that I wasn't happy enough with to include yet, but might be worth finishing to fill in the \"Pool/ Channel management on the server side\" part from https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/61 that I skipped when closing that issue.\r\n\r\nThe goal really is to make it clear what kinds of channel assignment strategies you'd want for a few different use cases, which I don't think this text quite achieves.\r\n\r\nI'm not sure it's worth it, it seems like a lot of background in order to cover some non-normative example stuff that might be better done by an example implementation outside the spec, but I thought I'd leave this here for a bit more discussion instead of just dropping the \"pool/Channel management\" suggestion.\r\n\r\nMaybe it would be better with a slightly different direction I just haven't thought of properly, I'm not sure.  But this is what my interpretation started out typing, until it kinda felt like maybe more of a can of worms than it's worth, so I thought I'd dump it in here for possibly a later rev.\r\n\r\nPlease do suggest direction or text here if you think there's something worth filling out and incorporating, but I'm kind of inclined to drop it at the moment.\r\n\r\n----\r\n\r\n## Application Use Cases {#application-use-cases}\r\n\r\nThis section covers some potentially useful applications and some of their deployment considerations if using multicast QUIC for the data delivery.\r\n\r\n### Live Adaptive Bitrate Media\r\n\r\nAdaptive bitrate media (for example using HLS {{RFC8216}} or DASH {{MPEG-DASH}}) that's either live or has high concurrency among end users (for example right after release of a new episode of a popular show) can benefit from leveraging multicast delivery because many end users are trying to consume the same data at roughly the same time.\r\n\r\nHowever, adaptive bitrate systems deliver different media segments to different end users according to the bitrate their network connections can support under the changing network conditions detected by the client.\r\n\r\nUseful techniques:\r\n - send each segment in a separate stream, so that there's no dependency on prior content in a stream that might not have been delivered to a client that switched bitrates\r\n - deliver the most popular or highest bitrate content over multicast, and deliver lower bitrates or bitrates with fewer consumers over unicast.\r\n\r\n### Pre-loading Popular Video Clips\r\n\r\nVideo clips that will predictably be delivered to many users can usefully be delivered and cached with multicast QUIC, then served from cache when appropriate.\r\n\r\nFor example, advertisements for a cohort of end users or \"trending\" video clips for social media applications that have a wide audience might be delivered on a multicast channel that the server asks clients to join according to group memberships they have within the social media application.  Then as users scroll their media feed, the advertisements or the popular video clips that are already pre-positioned can be inserted in the feed where appropriate without new network traffic (playing the content from a local cache), even though the users' consumption of these clips may not be synchronized.\r\n\r\n### File Transfer\r\n\r\nExisting unidirectional file transfer protocols based on ALC {{RFC5775}} and FEC {{RFC6363}} can leverage multicast to send the same file to many end users even though they might start at different times and consume the data at different rates.\r\n",
      "createdAt": "2022-06-23T05:29:58Z",
      "updatedAt": "2022-07-06T18:08:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Fixed in https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/78",
          "createdAt": "2022-07-06T18:08:48Z",
          "updatedAt": "2022-07-06T18:08:48Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOG6NyZs5MdHTA",
      "title": "Add section on what frames are required to be retransmitted ",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/77",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Jakes comment: \r\n\r\n`Other kinds of frames besides streams also need to be retransmitted (like RESET_STREAM, as well as MC_INTEGRITY, MC_RETIRE, MC_LEAVE). Likewise other kinds of frames besides DATAGRAM frames don't get retransmitted (like PING and PADDING). I tried to leave it generic, but maybe we need a reference to https://www.rfc-editor.org/rfc/rfc9000.html#section-13.3 and https://www.rfc-editor.org/rfc/rfc9221.html#section-5.2 plus a similar section in this doc to list what gets retransmitted? `",
      "createdAt": "2022-06-23T17:04:19Z",
      "updatedAt": "2022-06-23T17:04:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 82,
      "id": "I_kwDOG6NyZs5NG7Ze",
      "title": "Do bitfields really need to be up to 62 bits long?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/82",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "In a few places there is `Capabilities Flags (i)`, which is a varint that can provide between 6 and 62 bits. Given that there are only two things currently defined, this is a slight waste of space if implementations don't minimally encode. It also introduces potential interop issues if you don't define MSB or LSB. If we stick with that design, some more text would probably be required.\r\n\r\nA different approach here is to just list out the bits e.g. assuming 8-bit alignment is desirable, the smallest thing we could do is\r\n\r\n```\r\nIPv4 capable (1),\r\nIPv6 capable (1),\r\nReserved(6),\r\n```\r\n\r\nthis would give back 2 bits otherwise consumed by the varint encoding, and allow up to 6 more future capabilities.\r\n\r\nThere's a tradoff either way but given that these fields won't be sent often, I don't think we need to over-optimize.\r\n",
      "createdAt": "2022-07-05T00:48:22Z",
      "updatedAt": "2022-07-06T19:20:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I agree it doesn't much matter in terms of performance, and that if we leave it the way it is a bit more text is required.\r\n\r\nA bit of brainstorming came up with 2-3 more bits that might theoretically be worthwhile additions for future extensions if anyone ever has a use case (namely: dns, asm, and a new ip version).\r\n\r\nSo I guess I'd be comfortable making this an 8-bit fixed field and requiring a heavier weight extension if we run out due to unforeseen needs.",
          "createdAt": "2022-07-06T19:20:54Z",
          "updatedAt": "2022-07-06T19:20:54Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOG6NyZs5NG8mj",
      "title": "MC_STATE: consider using MACRO_CASE",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/83",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Style comment. The state and reason fields are variable-length integers, which makes them quite like RFC 9000 Error Codes. For consistency, my suggestion is to use MACRO_CASE for the values defined in this document. E.g instead of `Property Violation` use `PROPERTY_VIOLATION`. This can make it easier to slot into existing enum-based handling or logging systems.",
      "createdAt": "2022-07-05T00:59:33Z",
      "updatedAt": "2022-07-07T15:35:51Z",
      "closedAt": "2022-07-07T15:35:51Z",
      "comments": []
    },
    {
      "number": 84,
      "id": "I_kwDOG6NyZs5NG9rq",
      "title": "MC_STATE: don't overload connection and application Reason code spaces",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/84",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "The MC_STATE `Reason` field provides a shared code space for connection and application errors. This is quite different from how RFC 9000 does things, whereby CONNECTION_CLOSE indicates connection or application errors via the Frame type. This separation allows all transport concerns to be managed by one set of experts, while delegating application concerns to a different set of experts. That scales well.\r\n\r\nI don't see much strong reason to deviate from the design QUIC already uses. The example in https://www.ietf.org/archive/id/draft-jholland-quic-multicast-01.html#section-12.1.1 highlights that an H3 implementation would need to model another error code `0x1000108` somehow, and it would be awkward to figure out where that actually gets registered.\r\n\r\nSo in summary, I suggest just defining two types of MC_STATE frame",
      "createdAt": "2022-07-05T01:09:41Z",
      "updatedAt": "2022-07-07T15:38:37Z",
      "closedAt": "2022-07-07T15:38:37Z",
      "comments": []
    },
    {
      "number": 85,
      "id": "I_kwDOG6NyZs5NG-RY",
      "title": "Mandate the shortest possible encoding of some varint fields?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/85",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "There's a few fields that are variable-length integers, which are used to communicate only a handful of defined types. I'm guessing this is done to hedge some bets against future growth; that seems ok. But that leaves the door open to implementations doing annoything things like encoding 0x1 in 62 bits. \r\n\r\nRFC 9000 includes a requirement that *frame types* are encoded using the smallest integer encoding https://www.rfc-editor.org/rfc/rfc9000.html#section-12.4-18. We might want to levy a similar requirement in this document",
      "createdAt": "2022-07-05T01:14:45Z",
      "updatedAt": "2022-07-06T18:31:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 86,
      "id": "I_kwDOG6NyZs5NG_Np",
      "title": "GREASING fields?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/86",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "There's a few fields that are varints, supporting a huge 62-bit space of values. Yet only a handful of values are defined in this spec.\r\nThat leaves plenty of space for future extension, but we've learned that you have to \"use it or lose it\". QUIC addresses this concern by GREASING a.k.a reserving a wide range of values that have no meaning and must be ignored - https://www.rfc-editor.org/rfc/rfc9000.html#section-22.3-7\r\n\r\nWe might want to consider similar here.\r\n",
      "createdAt": "2022-07-05T01:22:53Z",
      "updatedAt": "2022-07-10T01:05:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Scanning thru the frames, I see:\r\n- MC_STATE state\r\n- MC_STATE reason\r\n- Capabilities in MC_LIMITS and Tranport Parameter\r\n\r\nI think the rest are all numerical values, did I miss any that you noticed?\r\n\r\nFor what to do with those, my initial thoughts are:\r\n\r\n- I think we could make the MC_STATE state field a fixed size probably.  It's hard to imagine what to do with an unknown state value besides tell the client to close the channel or maybe close the connection?\r\n- The reason field in MC_STATE seems more analogous to the error code in CONNECTION_CLOSE, which I notice doesn't have any extra GREASE defined the way Transport Parameters does. (But I think nothing stops an implementation from sending undefined values by way of GREASE handling?  Maybe that should be explicit?)\r\n- I guess the bits in Transport Parameter's capabilities are sent without knowing what the server can support, so these have to be ignored by servers that don't understand them.  I'm not sure how a client can grease these without potentially advertising support for something it doesn't actually support, do we have any analogies in QUIC for a case like this?\r\n\r\nActually, thinking thru the capabilities again is making me realize we maybe also need something besides MC_ANNOUNCE sent server-to-client to indicate server has multicast support, else a client can't send a new MC_LIMITS.  Hmm, I think I will open a new issue for that. (edit: opened https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/95)",
          "createdAt": "2022-07-06T22:05:48Z",
          "updatedAt": "2022-07-06T22:51:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's useful to think about this throught the eye of extensibility. Is there anything we might add later that is safe to send without waiting for the peer to tell us it is safe first. The way to do this is to ignore unknown values. That's a design choice this specification should be clear about whether it supports it or not.\r\n\r\nGiven that there is a PR to change the capabilities to be a bit field, that is going to constrain the scope of problem that GREASING is intended to address. So I don't think any greasing is required there.\r\n\r\nSo then we are left with MC_STATE `State` or `Reason` codes. It turns out that, for some reason, QUIC transport doesn't GREASE error codes but HTTP/3 does. That might have been the reason for part of the confusion. Personally, given that the `State` field can potentially have non-trivial impact on the protocol at runtime, I think there is some benefit in asupporting future extensions via ignoring unknown state values and greasing that field. But maybe you disagree?\r\n\r\nI'm not so worried about the Reason code, that's probably mostly used for logging or offline purposes.\r\n\r\n",
          "createdAt": "2022-07-09T15:06:10Z",
          "updatedAt": "2022-07-09T15:06:10Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I guess if we assume other possible values for state are only in the style of DECLINED_JOIN, where they don't actually come with a change in the state, then we could ignore other values and grease them (like a REPORT_STATUS or something?  A \"NETWORK_SUPPRESSED\" that you could send in addition to your separate JOINED state to indicate to servers that understand it that traffic is not actually expected because of a future multicast feature that reports success/failure of the IGMP membership propagation to the client, and a corresponding NETWORK_UNSUPPRESSED?).\r\n\r\nBy default I was thinking if we need future extensions to the state transition signals, they may or may not be no-ops to the current state, so ignoring them might not be right, and therefore support for the new improved state transitions would have to be negotiated in an updated transport parameters or something, and you're forbidden from sending unknown state transition signals to endpoints that haven't negotiated support for them, on pain of connection close/MC_EXTENSION_ERROR.\r\n\r\nI guess I'm pretty agnostic here.",
          "createdAt": "2022-07-10T00:57:52Z",
          "updatedAt": "2022-07-10T00:57:52Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "However, this line of reasoning suggests to me that maybe we should have a list of capabilities (which can have unknown greasable capabilities) in the transport parameters instead of just a bitfield for ipv4/ipv6.  Like maybe there's a difference between \"I am currently capable of joining an IPv4 group\" and \"I understand how to interpret IPv4 addresses\", and the 2nd could be a listed capability among potentially numerous capabilities, whereas the first remains a bit that can be updated by a later MC_LIMITS.",
          "createdAt": "2022-07-10T01:02:44Z",
          "updatedAt": "2022-07-10T01:05:57Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOG6NyZs5NHABE",
      "title": "Integrity and MC_INTEGRITY",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/87",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "Section 4.3 says:\r\n\r\n> Data transmitted in a multicast channel is encrypted with symmetric keys so that on-path observers without access to these keys cannot decode the data. However, since potentially many receivers receive identical packets and identical keys for the multicast channel and some receivers might be malicious, the packets are also protected by MC_INTEGRITY ([Section 10.5](https://www.ietf.org/archive/id/draft-jholland-quic-multicast-01.html#channel-integrity-frame)) frames transmitted over a separate integrity-protected path.\r\n\r\n> A client MUST NOT decode packets on a multicast channel for which it has not received a matching hash in an MC_INTEGRITY frame over a different integrity-protected communication path. The different path can be either the unicast connection or another multicast channel with packets that were verified with an earlier MC_INTEGRITY frame.\r\n\r\nMy initial comprehension was that MC_INTEGRITY frames are only delivered over the unicast channel, so they are always delivered in packets that have integrity, confidentiality and authenticity.\r\n\r\nBut this section focuses on integrity, via using the term \"integrity-protected path\". This makes me wonder whether there is a design intention to allow MC_INTEGRITY frames related to multicast channel A, to be delivered on multicast channel B, as long as the packet containing the MC_INTEGRITY frame has a chain of integrity back to some root (avoiding a bootstrap issue). The document doesn't really go into detail here and I think it would help to be a little clear if such a deployment is intended to be allowed.",
      "createdAt": "2022-07-05T01:30:56Z",
      "updatedAt": "2022-07-09T14:52:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Good point, it's a relatively common point of confusion and could use clearing up.\r\n\r\nTo answer the question: yes, the design intent is to allow MC_INTEGRITY frames to be carried in a multicast channel.  An MC_INTEGRITY frame carried in a channel of course requires its packet to be secured by another MC_INTEGRITY frame that contains its hash that was delivered on a secure channel such as the unicast connection, which would form a [merkle tree](https://en.wikipedia.org/wiki/Merkle_tree).\r\n\r\nAlso note: @squarooticus in https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/48 wants to tweak the text to permit the secure hash delivery to occur in out-of-band paths like [AMBI](https://datatracker.ietf.org/doc/html/draft-ietf-mboned-ambi).  I'm not fully convinced that's worth including in this spec, but have deferred judgement on the point for now.  And in general I agree with him that it's feasible to use an integrity anchor that comes from outside the current connection in ways that can provide adequate security--my unsureness here is about whether this is a can of worms that's worth leaving open in this doc, and whether it's likely to provoke any needlessly difficult discussions.",
          "createdAt": "2022-07-06T20:01:58Z",
          "updatedAt": "2022-07-06T20:01:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The merkle tree thing is an \"obvious\" next step in a reasoning chain, the new text in the PR does a good job of \"stating the obvious\". I'm happy with that right now. I don't know enough about AMBI to have a useful opinion - maybe that's something that today's design allows to happen in the future but without needing to add complication to an MVP spec,",
          "createdAt": "2022-07-09T14:52:42Z",
          "updatedAt": "2022-07-09T14:52:42Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "I_kwDOG6NyZs5NHA0h",
      "title": "Channel idle timeouts",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/88",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "Has any consideration been given to channel idle timeouts? That is, if the channel-related comms go quiet, the channel is cleaned away without a flood of chatter. This might help avoid thundering herds of MC_STATE messages coming back from clients.",
      "createdAt": "2022-07-05T01:38:17Z",
      "updatedAt": "2022-07-09T14:50:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "We had client-side idle timeouts in an earlier version, but later realized we probably shouldn't.  Gave the reasoning in 4.2 (\"Client Response\") (and hit it again lightly under \"Circuit Breakers\" in the \"Graceful Degradation\" section).  Maybe we need more?\r\n\r\nAnd are you suggesting a protocol change, like that we need to refresh the channel state on the connection periodically if it's been joined without traffic for long enough?  Or more like text on how to handle it right if no data is flowing?",
          "createdAt": "2022-07-06T18:00:09Z",
          "updatedAt": "2022-07-06T18:00:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I probably need to think about it some more :-)",
          "createdAt": "2022-07-09T14:50:07Z",
          "updatedAt": "2022-07-09T14:50:07Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOG6NyZs5NHBG8",
      "title": "What happens when \"not permitted\" frames are received",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/89",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Section 11 lists a load of frames that aren't allowed. What does a client do if it does receive one? Closing the connection (and all channels) seems like the safest option.",
      "createdAt": "2022-07-05T01:40:46Z",
      "updatedAt": "2022-07-07T15:38:30Z",
      "closedAt": "2022-07-07T15:38:30Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "I_kwDOG6NyZs5NHBZ_",
      "title": "Consider an MC_EXTENSION_ERROR error code",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/90",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Section 3 lists some instances that an endpoint might close a connection and states that a `PROTOCOL_VIOLATION` error code be used. Since the problems are actually due to the behaviour defined in this extension, it might be prescient to define a specific error code that can disambugate the underlying problem.",
      "createdAt": "2022-07-05T01:43:24Z",
      "updatedAt": "2022-07-07T15:38:24Z",
      "closedAt": "2022-07-07T15:38:24Z",
      "comments": []
    },
    {
      "number": 91,
      "id": "I_kwDOG6NyZs5NHB0b",
      "title": "What's a \"liveness test\"?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/91",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "> If the unicast connection becomes idle and the server does not respond to a liveness test, the client MUST terminate the connection as described above.\r\n\r\nI don't follow this. QUIC endpoints that want to avoid the connection going idle are obligated to keep to it alive. There isn't a concept of testing after the period has elapsed, that would be too late.",
      "createdAt": "2022-07-05T01:47:00Z",
      "updatedAt": "2022-07-07T15:38:18Z",
      "closedAt": "2022-07-07T15:38:18Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Probably me not being clear enough, I was trying to refer to section 10.1.1. and the mechanic described there, I will rephrase. ",
          "createdAt": "2022-07-05T12:25:19Z",
          "updatedAt": "2022-07-05T12:25:19Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOG6NyZs5NHCJs",
      "title": "Deleting old stuff seems arbitrary",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/92",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "Section 10.2 says\r\n\r\n> Clients MUST delete old secrets within 10 seconds after receiving a new key, and within 3 seconds after receiving a new key and not receiving any data traffic decrypted with the old key.\r\n\r\nMy first question is why is it a MUST. My second question is why these values? \r\n\r\nSince this is a client behaviour that is hard for the peer to enforce, it would help to explain the rational behind these requirements so that implementations `Do the Right Thing`.",
      "createdAt": "2022-07-05T01:49:42Z",
      "updatedAt": "2022-07-09T14:49:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "The MUST delete is for forward secrecy.  Like in TLS, if all clients have deleted all keys, the key exposure footprint is reduced to only what's necessary.\r\n\r\nThe time choices are arbitrary, yes.  I wanted something in there, but I don't have a principled answer for what they should be.  It's possible that these should be server-advertised values instead of a client-side constant, but I'd expect for most practical purposes a time-based hard limit will suffice.\r\n\r\nMaybe we should add this to the list of things we hope to learn by making this experimental, like the congestion control handwaviness?",
          "createdAt": "2022-07-06T19:38:07Z",
          "updatedAt": "2022-07-06T19:38:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "yep sounds all good",
          "createdAt": "2022-07-09T14:49:23Z",
          "updatedAt": "2022-07-09T14:49:23Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDOG6NyZs5NHCXH",
      "title": "Why be frugal with MC_KEY?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/93",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [],
      "body": "Section 10.2 says:\r\n\r\n> A server SHOULD NOT send MC_KEY frames for channels except those the client has joined or will be imminently asked to join.\r\n\r\nThat sounds sensible but my question is, why shouldn't they? If they ignore the recommendation, what can go wrong?",
      "createdAt": "2022-07-05T01:51:31Z",
      "updatedAt": "2022-07-06T19:32:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Good point, thanks.  I think the answer is \"principle of least trust\" from RFC 4949, which in this instance tells us we should not deliberately leak keys to clients that don't need them, as that would increase the key exposure footprint unnecessarily.",
          "createdAt": "2022-07-06T19:32:07Z",
          "updatedAt": "2022-07-06T19:32:07Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDOG6NyZs5NHDFT",
      "title": "MC_STATE: reason can be 0-length?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/94",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-jholland-quic-multicast-01.html#figure-12\r\n\r\n```\r\nMC_STATE Frame {\r\n  Type (i) = TBD-0b (experiments use 0xff3e80b),\r\n  Client Channel State Sequence Number (i),\r\n  ID Length (8),\r\n  Channel ID (8..160),\r\n  State (i),\r\n  Reason (0..i)\r\n}\r\n```\r\n\r\nThis implies `Reason` can be 0-length, which seems odd and I'm not sure a frame parser could acutally handle this unless it new the field was going to be 0-length (I.e. the field is optional, usually indicated by the frame type or another field in the frame.\r\n\r\nSuggest this is just made to be `Reason (i)`, unless I'm missing something.",
      "createdAt": "2022-07-05T01:57:43Z",
      "updatedAt": "2022-07-07T15:38:12Z",
      "closedAt": "2022-07-07T15:38:12Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the intention is that for cases when the state is Joined or Retired the reason field is 0-length, so the parser could learn it off of that I guess. It would always have to be present for the Left or Declined Join cases. Probably needs rephrasing to be more clear on that. ",
          "createdAt": "2022-07-05T12:28:38Z",
          "updatedAt": "2022-07-05T12:29:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation. That's a deviation from the way other QUIC frames are described or handled.\r\n\r\nI would suggest avoiding deviations and following familiar patterns. Either always send an error code, or model the frame type around a bit field model - I.e. you encode the `State` field in the type and then that determines if there is a Reason field or not ",
          "createdAt": "2022-07-05T12:34:06Z",
          "updatedAt": "2022-07-05T12:34:06Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yeah, we missed this one when refactoring out a similar problem in an earlier draft, thanks.  I like the idea of:\r\n- reason is always present (and I guess always 0 for MC_JOIN or MC_RETIRE)\r\n- 2 different frame types for application vs. protocol, very similar to [CONNECTION_CLOSE](https://www.rfc-editor.org/rfc/rfc9000.html#name-connection_close-frames)\r\n\r\nI'm even kinda thinking it might also be useful to include another 2 types or a length+bytes to support an optional Reason Phrase, like connection close.  Not sure we need it, but it might be helpful.",
          "createdAt": "2022-07-06T21:16:02Z",
          "updatedAt": "2022-07-06T21:16:11Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDOG6NyZs5NSCO7",
      "title": "Add a server-to-client transport parameter",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/95",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There's a failure mode for instance where client starts with an IPv4-only interface and advertises only IPv4 capabilities but server has only IPv6 groups, so it never sends any MC_ANNOUNCE, nor any other multicast-related frames.\r\n\r\nClient then gains an IPv6 address and adds IPv6 capability, but unless client knows it's safe to send a new MC_LIMITS there's not a way to tell server, right?\r\n\r\n(Or alternately, if client sends an MC_LIMITS to a server that doesn't support multicast (which the client doesn't know in the current spec if it never saw a multicast-related frame) serve will close the connection from seeing an unknown frame.)\r\n\r\nOne answer would be to add a server-to-client transport parameter that declares multicast support.  (Any useful data to include in it?  Capabilities flags saying what kinds of capabilities it supports, maybe?) I'm not sure if there's other good options.",
      "createdAt": "2022-07-06T22:50:47Z",
      "updatedAt": "2022-07-06T22:50:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 101,
      "id": "I_kwDOG6NyZs5Nd8_z",
      "title": "What if MC_ANNOUNCE contains bogus IPs",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/101",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The Source IP and Group IP have certain requirements. If I receive an MC_ANNOUNCE where e.g. the Group IP is not in the multicast IP range, what should I do? \r\n\r\nOne option is to say that senders MUST send valid values as per RFC 4607, and that receivers of bad values MUST ignore them, or that they MUST ignore them, or something along those lines. I didn't think much through the ramifications of this, maybe you have more opinion or experience?",
      "createdAt": "2022-07-09T14:42:30Z",
      "updatedAt": "2022-07-10T00:13:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yeah, good point.  The reaction should be specified.  My first idea is that declining a join to such a channel with a new reason like UNUSABLE_ADDRESS might be right.  We don't really have a way to object to an announce, but refusing a join is easy.  (BAD_ADDRESS also might be applicable for addresses that are multicast but reserved, or that are in a range that isn't for SSM.)",
          "createdAt": "2022-07-10T00:13:08Z",
          "updatedAt": "2022-07-10T00:13:08Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDOG6NyZs5OlGaK",
      "title": "How to deal with frames of other QUIC extensions ",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/102",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 11 has a list of permitted and not permitted frames, we should probably make it more explicit that the list isn\u2019t exhaustive and that frames that are introduced by future QUIC extensions should be handled on a common sense basis (or similar)",
      "createdAt": "2022-07-26T14:42:48Z",
      "updatedAt": "2022-07-26T14:46:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, Reading the list, why are ANNOUNCE and JOIN frames not allowed? It would make failovers more easy to handle when you know this channel will soon close (for whatever reason) and clients should switch to an new one",
          "createdAt": "2022-07-26T14:45:54Z",
          "updatedAt": "2022-07-26T14:46:05Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOG6NyZs5OwT19",
      "title": "Need MC_HAMMER",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/103",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "humor"
      ],
      "body": "![mc_hammer](https://user-images.githubusercontent.com/3170247/181605142-25a994a3-d256-4f49-b36d-ad7a3d30b1cd.png)\r\n",
      "createdAt": "2022-07-28T17:55:40Z",
      "updatedAt": "2022-08-02T00:42:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "What are the odds that renaming the MC_RETIRE frame to MC_HAMMER will make it through the RFC editor? ",
          "createdAt": "2022-07-31T14:20:17Z",
          "updatedAt": "2022-07-31T14:20:17Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "The low bar was set by \"6bone\", so I feel we could probably get away with a lot here.",
          "createdAt": "2022-07-31T14:35:10Z",
          "updatedAt": "2022-07-31T14:35:10Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "I_kwDOG6NyZs5O4qBJ",
      "title": "Move channel id to first field in join frame",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/104",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "All frames except the join frame start with the channel id length and then the channel id, except the Join frame where it is at the end. ",
      "createdAt": "2022-07-31T14:19:04Z",
      "updatedAt": "2022-08-11T04:52:31Z",
      "closedAt": "2022-08-11T04:52:31Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Same for MC_STATE actually",
          "createdAt": "2022-07-31T14:43:28Z",
          "updatedAt": "2022-07-31T14:43:28Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "I_kwDOG6NyZs5PIiLY",
      "title": "Receive different keys with same sequence number on different paths",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/105",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-03T18:36:41Z",
      "updatedAt": "2022-08-22T11:59:29Z",
      "closedAt": "2022-08-22T11:59:29Z",
      "comments": []
    },
    {
      "number": 106,
      "id": "I_kwDOG6NyZs5PR49E",
      "title": "Change transport parameters to use a list of capabilities instead of just sharing the limits bit field",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/106",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Also: GREASE the list of capabilities (both sides should indicate the capabilities to ever handle ipv4 and v6, where the limits bit field just indicates what the client will accept right now).",
      "createdAt": "2022-08-05T15:37:02Z",
      "updatedAt": "2022-08-05T15:37:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDOG6NyZs5PR5dA",
      "title": "Add hostname to the secret before generating the key",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/107",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This binds the encryption/decryption of the channel to the tls session hostname used to open the tls session in the unicast connection.",
      "createdAt": "2022-08-05T15:39:11Z",
      "updatedAt": "2022-08-05T15:43:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Also: add a transport parameters feature to indicate that this is the way to do the decryption, so that we can change to other alternatives in the future if necessary, so you can bind it to a different thing besides the tls hostname in the future?  (Is there a chance we might need that?)",
          "createdAt": "2022-08-05T15:43:53Z",
          "updatedAt": "2022-08-05T15:43:53Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDOG6NyZs5QExLx",
      "title": "Martins review - Give more details on application workflow",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/109",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MD: I don't really understand the workflow here, and I wonder if explicit discussion of what you're expecting the application layer to do would be helpful. Let's say a client connects to [liveevents.example.com](http://liveevents.example.com/). Say the server has 100 different programs, each with 3 channels corresponding to different data rates.\r\n\r\nThis is a very push-oriented model. The server uses MC_ANNOUNCE, potentially to list all 300 channels. It can't send MC_JOIN to all of them, since that would violate capacity limits, so it has to divine what the client wants. Presumably this is being driven by an application-level request protocol (HTTP or whatever) that allows the server to tell QUIC what channel to push. Is this right?",
      "createdAt": "2022-08-18T17:58:25Z",
      "updatedAt": "2022-08-18T18:00:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 110,
      "id": "I_kwDOG6NyZs5QExkI",
      "title": "Martins review - Give more details on why ANNOUNCE and JOIN frames have to be separate",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/110",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "MD: Relatedly, I don't understand why MC_ANNOUNCE and MC_JOIN have to be different frames. There could be a super-frame that has all of this (in addition to MC_KEY information, though that frame also has to have a separate incarnation for re-keying), which would streamline the client state machine considerably. Put differently, I don't see the value of the \"unjoined\" state.",
      "createdAt": "2022-08-18T18:00:07Z",
      "updatedAt": "2022-08-31T18:08:03Z",
      "closedAt": "2022-08-31T18:08:03Z",
      "comments": []
    },
    {
      "number": 111,
      "id": "I_kwDOG6NyZs5QEyUS",
      "title": "Add an implementation section",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/111",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Things to include: \r\n- Stream ID assignment is complicated\r\n- Retransmissions are complicated\r\n- Channel ID length might cause issues as the client doesn't necessarily know the length",
      "createdAt": "2022-08-18T18:03:31Z",
      "updatedAt": "2022-08-18T18:43:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 112,
      "id": "I_kwDOG6NyZs5QEyfB",
      "title": "Martins review - MC ANNOUNCE/ JOIN could have meta data for the current streams",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/112",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MD: (4.4) It might be useful for MC_ANNOUNCE or JOIN to have up-to-date stream information; how many streams are open, and what is the highest index. In practice, I don't see how a server could support two channels on one connection unless channels are assigned unique stream ID ranges.\r\n\r\nIt would be useful for MC_ANNOUNCE or JOIN to contain stream information (max number of open streams, highest stream ID) so that the client could update its flow control and make a better decision about joining the channel.\r\n",
      "createdAt": "2022-08-18T18:04:16Z",
      "updatedAt": "2022-08-18T18:04:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 113,
      "id": "I_kwDOG6NyZs5QEz_s",
      "title": "Martins review - Loss detection on the client -> make packet numbers continuous ",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/113",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "MD: (6) How does the client measure packet loss? It's worth pointing out that there is no receiver packet loss detection mechanism in QUIC, so this has to be invented out of whole cloth. Reading between the lines both here and in the MC_INTEGRITY section, I think you have an implied requirement that servers MUST NOT skip packet numbers in the channel; if so, write that down.",
      "createdAt": "2022-08-18T18:11:04Z",
      "updatedAt": "2022-08-31T21:28:40Z",
      "closedAt": "2022-08-31T21:28:40Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #123 ",
          "createdAt": "2022-08-31T21:28:39Z",
          "updatedAt": "2022-08-31T21:28:39Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "I_kwDOG6NyZs5QE0WR",
      "title": "Martins review - Explain why we need separate key rotation mechanism",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/114",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MD: (10.2) I can almost figure out for myself why normal key phase rotation would be insufficient, so that you need MC_KEY, but it would be nice for it to be written down.",
      "createdAt": "2022-08-18T18:12:38Z",
      "updatedAt": "2022-08-18T18:12:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 115,
      "id": "I_kwDOG6NyZs5QE1zI",
      "title": "Martins Review - What happens if both IPv4 and IPv6 are disallowed in a LIMITS frame?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/115",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MD: (3) I take it that if MC_LIMITS says that both IPv4 and IPv6 are disallowed, this is a way of turning of multicast capability after having initially advertised it, or vice versa? Or is setting both to zero not allowed?\r\n",
      "createdAt": "2022-08-18T18:19:16Z",
      "updatedAt": "2022-08-22T11:58:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 116,
      "id": "I_kwDOG6NyZs5QE15b",
      "title": "Martins review - Please specify what frames count against cwnd -- I would imagine everything except MC_ACK.",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/116",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-18T18:19:40Z",
      "updatedAt": "2022-08-18T18:19:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 117,
      "id": "I_kwDOG6NyZs5QE2yQ",
      "title": "Martins Review - Initial MC_INTEGRITY frames have to be anchored",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/117",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MD: (7 and 10.5) IIUC, it's fine for MC_INTEGRITY frames to be sent on the channel, but it's important that the \"root\" MC_INTEGRITY frame is sent on the unicast channel. Otherwise, channel A could send MC_INTEGRITY for channel B and vice versa, and I believe that would not be effective against the threat model.",
      "createdAt": "2022-08-18T18:22:01Z",
      "updatedAt": "2022-08-18T18:22:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 118,
      "id": "I_kwDOG6NyZs5QE3Db",
      "title": "Martins review - Rename \"Header AEAD algorithm\"",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/118",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "MD: (10.1) \"Header AEAD algorithm\" is a weird way of putting it. It's not an AEAD algorithm; instead RFC 9001 designates an header algorithm (AES-ECB or raw ChaCha20) depending on the AEAD algorithm used for payload protection.",
      "createdAt": "2022-08-18T18:22:44Z",
      "updatedAt": "2022-08-31T21:28:51Z",
      "closedAt": "2022-08-31T21:28:51Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #123 ",
          "createdAt": "2022-08-31T21:28:51Z",
          "updatedAt": "2022-08-31T21:28:51Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDOG6NyZs5QE3Rw",
      "title": "Martins review -  Ack-frequency ",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/119",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MD: Is it intended for MC_ACK to be any less than once every two packets, or are you take the ack-frequency extension and extend it to MC_ACK?",
      "createdAt": "2022-08-18T18:23:45Z",
      "updatedAt": "2022-08-18T18:23:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 120,
      "id": "I_kwDOG6NyZs5QE3oq",
      "title": "Martins Review - Rephrase retiring of channels",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/120",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "MD: (10.8) \"After retiring a channel, the client...\" makes it sound like the client sends MC_RETIRE. How about \"After receiving MC_RETIRE,...\"\r\n\r\nTo add to your explanation about RETIRE_CONNECTION_ID, this frame is sent by the creator of the connection ID, which receives packets with that CID. The valence here is different: the creator of the channel ID is also the sender.",
      "createdAt": "2022-08-18T18:25:16Z",
      "updatedAt": "2022-08-31T21:29:06Z",
      "closedAt": "2022-08-31T21:29:06Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #123 ",
          "createdAt": "2022-08-31T21:29:06Z",
          "updatedAt": "2022-08-31T21:29:06Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "I_kwDOG6NyZs5QE4Iz",
      "title": "Martins Review - Nits",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/121",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [],
      "body": "Nits\r\n~~~\r\n(5) \"Desynchronized Limit Violation\" should probably be capitalized and added to the registry.\r\n\r\n(12.1) If it's convenient for some reason, the server could also send preceding data on that stream on the unicast connection to catch the client up.",
      "createdAt": "2022-08-18T18:27:27Z",
      "updatedAt": "2022-08-31T21:29:22Z",
      "closedAt": "2022-08-31T21:29:22Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #123 ",
          "createdAt": "2022-08-31T21:29:22Z",
          "updatedAt": "2022-08-31T21:29:22Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "I_kwDOG6NyZs5QkDaj",
      "title": "Constraints on Stream Data section",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/124",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-jholland-quic-multicast-02.html#section-12.1 describes some constraints. And https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/123/files adds even more commentary.\r\n\r\nI think the section is mildly problematic. I makes a sweeping claim that applications can't use data if they don't receive it from stream 0, and suggests some server actions based on convenience (which is not well defined), I'm not suggesting these things are wrong. \r\n\r\nHowever, I think the section can be rephrased to make things clearer. For example, imagine an application protocol that sends a infinite series of fixed size atomic data units on the stream, and supports random access of these units. A client that comes late to the stream can easily determine the start of the next unit by looking at the stream offset. Once it's done that, it will just pick up that unit and make progress. A server _could_ retransmit the entirety of the stream before this point, but that might not make sense for the application protocol. ",
      "createdAt": "2022-08-26T01:50:26Z",
      "updatedAt": "2022-08-26T12:02:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yeah, we thought about that a bit.  The first version had a concept of a \"stream boundary\" that was meant to allow this kind of thing, where a receiver could pick up a stream starting at a boundary and assume the data could be interpreted at the app level starting from there:\r\nhttps://www.ietf.org/archive/id/draft-jholland-quic-multicast-00.html#name-mc_channel_stream_boundary_\r\n\r\nWe decided it adds some complexity and not very much value as compared with just starting new streams as needed, so we dropped it, but if consuming stream id space is an issue it would be possible to bring it back.",
          "createdAt": "2022-08-26T06:07:37Z",
          "updatedAt": "2022-08-26T06:12:40Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "PS: yes, it's kind of looking like consuming stream ids wantonly does cause some complexity.  But is it better to allow a stream to start at an offset as though it was offset 0, or is it better to wrestle with the MAX_STREAM issues?\r\n\r\nI'm not actually sure yet, but I think we actually have to handle the MAX_STREAM issues regardless, so I'm still leaning toward not adding the new frame with new semantics for starting in the middle.",
          "createdAt": "2022-08-26T06:12:11Z",
          "updatedAt": "2022-08-26T06:12:11Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "That's reasonable. But IMO we shouldn't dictate or declare how application use transport features as heavily as the text implies. I'll prepare a PR that illustrates what I mean",
          "createdAt": "2022-08-26T08:14:26Z",
          "updatedAt": "2022-08-26T08:14:26Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "I_kwDOG6NyZs5Q79YH",
      "title": "Different algorithms for Header protection and packet protection",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/125",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do we need to keep this as an option or is it fine to just have the same for both? ",
      "createdAt": "2022-08-31T21:30:18Z",
      "updatedAt": "2022-08-31T22:57:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think you're right, this should be the same TLS Cipher Suite for both, and we should remove the option to have different ones.\r\n\r\nI read thru https://www.rfc-editor.org/rfc/rfc9001.html#section-5 again harder, particularly section 5.3, and it looks to me like the TLS cipher suite value uniquely determines both the AEAD algorithm and the header protection algorithm.",
          "createdAt": "2022-08-31T22:57:45Z",
          "updatedAt": "2022-08-31T22:57:45Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOG6NyZs5Q79pZ",
      "title": "Remove MC_STATE JOINED?",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/126",
      "state": "OPEN",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Is it enough to have it be implicit by sending ACKs for packets received on a channel?",
      "createdAt": "2022-08-31T21:31:40Z",
      "updatedAt": "2022-09-01T00:19:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Maybe.  I'm a little worried about the corner cases and state ambiguity here.\r\n\r\nI made an updated server state diagram if we do that, and sure, it's simpler:\r\nhttps://docs.google.com/presentation/d/1J1ISZFYUT-9nxX7vq17oNKAtDXZYv6KrXH4Y6AtiLSM/edit#slide=id.g14992269579_0_0\r\n\r\nI'm a little worried whether there's any issues if MC_ACKs arrive late and falsely indicate that we're in Join Confirmed from an older join, after we leave and rejoin a channel.\r\n\r\nAlso, packets containing only ACKs (and probably MC_ACKs, though I don't think we wrote it down yet) don't themselves get acked, so if early acks got dropped or if there's a pause in the data transfer such that you don't see any MC_ACKs, the server won't know if the client attempted to join and saw nothing yet or whether it's waiting before joining for some reason.\r\n\r\nMaybe it doesn't matter, but I'm not quite sure, and it seems to me harder to reason about, so harder to figure out if there's a problem, whereas the MC_STATE(Joined) provides a gate to verify that the state transition happened regardless of timing.  Maybe before we pin this down we should figure out how to do a formal analysis or something...\r\n",
          "createdAt": "2022-09-01T00:19:35Z",
          "updatedAt": "2022-09-01T00:19:35Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 6,
      "id": "PR_kwDOG6NyZs42gLSI",
      "title": "Attempt at addressing #1 ('no knowledge' on client data)",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/6",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-20T16:09:48Z",
      "updatedAt": "2022-04-21T15:19:58Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "d249bc0faa2309e91d63530012096dd3e0bf9c1a",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-1",
      "headRefOid": "69d9fb95fc1c49c5e458c786ff4147e4c5277e2c",
      "closedAt": "2022-04-21T15:19:31Z",
      "mergedAt": "2022-04-21T15:19:31Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "25235e6c1050245e0e21dbb826425a6dfab5776a"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Did you mean to merge instead of close it?",
          "createdAt": "2022-04-21T08:28:03Z",
          "updatedAt": "2022-04-21T08:28:03Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Yes, thanks.",
          "createdAt": "2022-04-21T15:19:58Z",
          "updatedAt": "2022-04-21T15:19:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs44f8Zk",
          "commit": {
            "abbreviatedOid": "69d9fb9"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-04-20T23:54:42Z",
          "updatedAt": "2022-04-20T23:54:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOG6NyZs42hLut",
      "title": "issue #5: be clearer about packet numbers in INTEGRITY",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/7",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-20T21:17:00Z",
      "updatedAt": "2022-04-21T06:10:08Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "d249bc0faa2309e91d63530012096dd3e0bf9c1a",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-5",
      "headRefOid": "612aa7b1a93b9f5aeae6bdd323e57b32a97c09b8",
      "closedAt": "2022-04-21T06:09:58Z",
      "mergedAt": "2022-04-21T06:09:58Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "8dc3669b3354172bcb984d0f9b426b2454a755e7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs44f9bo",
          "commit": {
            "abbreviatedOid": "612aa7b"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-04-21T00:04:18Z",
          "updatedAt": "2022-04-21T00:10:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This TODO should probably wait until AMBI went through last call I think? Any security reviews for AMBI would obviously also be very helpful for this. I also opened another [issue](https://github.com/GrumpyOldTroll/ietf-dorms-cluster/issues/11) recently that might become relevant here eventually (as its specifically concerning the hash algorithm). ",
              "createdAt": "2022-04-21T00:04:18Z",
              "updatedAt": "2022-04-21T00:10:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs44gtEA",
          "commit": {
            "abbreviatedOid": "612aa7b"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T06:09:35Z",
          "updatedAt": "2022-04-21T06:09:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yes, something like that. Ultimately I think a decent description of what this is protecting against probably belongs somewhere in this doc, so I thought I'd leave a placeholder.  Agreed there's a good chance reviews on AMBI will likely impact this.",
              "createdAt": "2022-04-21T06:09:35Z",
              "updatedAt": "2022-04-21T06:09:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOG6NyZs42heGh",
      "title": "attempt at fixing #3 and #4",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/8",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-20T23:02:37Z",
      "updatedAt": "2022-04-21T15:22:08Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "d249bc0faa2309e91d63530012096dd3e0bf9c1a",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-4",
      "headRefOid": "63b59b6058e9e00aa7f261fc478575dde0b19a78",
      "closedAt": "2022-04-21T15:22:02Z",
      "mergedAt": "2022-04-21T15:22:02Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "58475021be53111f46e1fd7bf52c0392efa02379"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Also about the failed checks, there is already a [PR against Martins Repo](https://github.com/martinthomson/i-d-template/pull/325). Apparently its because of a GitHub [security vulnerability.](https://github.blog/2022-04-12-git-security-vulnerability-announced/) ",
          "createdAt": "2022-04-21T00:29:49Z",
          "updatedAt": "2022-04-21T00:29:49Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM now, thanks! ",
          "createdAt": "2022-04-21T07:58:09Z",
          "updatedAt": "2022-04-21T07:58:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs44f635",
          "commit": {
            "abbreviatedOid": "97186e2"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Two (minor?) points, but definitely a lot clearer than before, thanks!",
          "createdAt": "2022-04-20T23:40:54Z",
          "updatedAt": "2022-04-20T23:52:40Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This isn't technically a new addition but I just noticed it, what kind of server do you mean when you speak of \"many servers\"? I assume its QUIC servers (processes)? The way its phrased now sounds a bit like it could describe ASM (many-to-many), which I am aware is not the intention. ",
              "createdAt": "2022-04-20T23:40:54Z",
              "updatedAt": "2022-04-20T23:52:40Z"
            },
            {
              "originalPosition": 21,
              "body": "How can a client differentiate if a packet belongs to a session or a connection if both use the same ID space? There should probably be a mechanic to force clients to not use some connection IDs for unicast connections. I think only doing it in the MC_SESSION_PROPERTIES frame is too late, it should probably be done immediately after the handshake of the unicast connection. Its basically a frame telling the client \"Do not use any of these connection IDs for your unicast streams as we might have a multicast session that uses this ID. If you (by sheer bad luck) already use one of them for a unicast connection (i.e. the initially created one), issue a new connection ID and retire the old one immediately.\" ",
              "createdAt": "2022-04-20T23:49:55Z",
              "updatedAt": "2022-04-20T23:52:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs44gU2L",
          "commit": {
            "abbreviatedOid": "97186e2"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T03:09:59Z",
          "updatedAt": "2022-04-21T03:09:59Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "That is a very good idea on a problem that has been bugging me.  I was thinking to do it by the receive path, but I like your idea better.\r\n\r\nI guess session properties should implicitly reserve the session id, but also a MC_RESERVE_SESSIONIDS frame to reserve a list of IDs without sending their properties.\r\n\r\nI think if there is a collision it doesn't matter until the server issues a JOIN, but if the client has not yet migrated connection ID it can refuse the join with an \"ID Collision\" reason and we don't really need other signaling about it I think?  Actually it occurs to me the server should already know if the connection ID is in use, and can determine when it has closed to retry the join?",
              "createdAt": "2022-04-21T03:09:59Z",
              "updatedAt": "2022-04-21T03:09:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs44gkML",
          "commit": {
            "abbreviatedOid": "97186e2"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T05:26:49Z",
          "updatedAt": "2022-04-21T05:26:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Made a new issue (#9) for this point, that'll be a separate PR.",
              "createdAt": "2022-04-21T05:26:49Z",
              "updatedAt": "2022-04-21T05:26:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOG6NyZs426Kbm",
      "title": "First attempt at stateless resets",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/17",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Would close #15 ",
      "createdAt": "2022-04-28T00:05:02Z",
      "updatedAt": "2022-05-02T18:06:34Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "234520ec2304bb110e8f8268de40bdb6f75ed3d0",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue15",
      "headRefOid": "9f7b3a5bc7b8235494c16c0028fc1d5c7b7ca6cd",
      "closedAt": "2022-05-02T18:06:34Z",
      "mergedAt": "2022-05-02T18:06:34Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "e266f4c5837f6331af1254b50b48fb38f197560f"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Reworded the section a bit again and added spurious traffic as a reason for leaving. Also note that I used (S,G), but that might change depending on #23.",
          "createdAt": "2022-04-30T01:27:24Z",
          "updatedAt": "2022-04-30T01:28:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs45DNO9",
          "commit": {
            "abbreviatedOid": "416bda9"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-04-28T23:33:30Z",
          "updatedAt": "2022-04-28T23:34:05Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I think this might be too strong.  An attack that injects a packet with a bad session id could cause everyone to leave.\r\n\r\nThat said, if there's a lot of traffic with an unknown session id arriving on a network path, I do think it's appropriate to leave, perhaps with a MAY, or with a SHOULD if it's above some threshold (not sure if we need it, but server could perhaps set a recommended threshold in session properties if we do?).  But I think this should be less about issuing an IGMP membership report and more like \"the client leaves the session(s) corresponding to the network path receiving excessive traffic with unknown session IDs with a leave reason of 'excessive spurious traffic'.\"",
              "createdAt": "2022-04-28T23:33:30Z",
              "updatedAt": "2022-04-28T23:34:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45DUvi",
          "commit": {
            "abbreviatedOid": "416bda9"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-29T00:55:28Z",
          "updatedAt": "2022-04-29T00:55:28Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I agree with the first part, good point thanks. I think it might be ok to say that it is the Group Address that can't be associated with any channel since the Endpoint should know all group addresses it expects traffic on. \r\n\r\nAs for the second part, as far as I understand stateless resets, it is for cases where the client loses all state so it might not know which the corresponding unicast connection is or it might lose that connection all together as well. I think the point is to just stop the sending/forwarding/receiving of useless data to not waste resources unnecessarily. (I think that's why stateless reset tokens can be generated from scratch if the only thing known is the connection ID for which to issue the stateless reset token). ",
              "createdAt": "2022-04-29T00:55:28Z",
              "updatedAt": "2022-04-29T00:56:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45DWBF",
          "commit": {
            "abbreviatedOid": "70773bd"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-29T01:12:31Z",
          "updatedAt": "2022-04-29T01:19:11Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Almost there, but I'll suggest:\r\n\r\nOLD:\r\n~~~\r\nAs clients can unilaterally stop the delivery of multicast packets by leaving the\r\nrelevant Group, channels do not need stateless reset tokens.\r\nInstead, if an endpoint receives packets addressed to a group IP that it can not\r\nassociate with any existing channel, it MAY take the necessary steps to prevent\r\nthe reception of further such packets. For example, it might issue an IGMP or\r\nMLD report indicating a desire to leave the (S,G) associated with the unwanted\r\npacket.\r\n~~~\r\n\r\nNEW:\r\n~~~\r\nAs clients can unilaterally stop the delivery of multicast packets by leaving\r\nchannels associated with network paths that receive traffic with unknown\r\nChannel IDs, channels do not need stateless reset tokens.\r\nInstead, if an endpoint receives packets addressed to a group IP that it can\r\nnot associate with any existing channel, it MAY leave channels using that\r\ngroup IP with reason \"spurious traffic\".\r\n~~~\r\n\r\nI think it's roughly equivalent in the end result, but I'm trying to talk in terms of the quic channel associated with the network path instead of the IP multicast group to the extent possible.\r\n\r\nAlso maybe as a separate but related matter we should clarify somewhere that the client MUST (or just SHOULD?) notify the server with a MC_CLIENT_CHANNEL_STATE frame when it joins and leaves channels associated with addresses of defined quic channels?  (The OLD text seems to indicate just stopping the receive at the IGMP/UDP layer without sending the MC_CLIENT_CHANNEL_STATE frame would be reasonable, and while that will eventually hit the max_idle, I don't think it's a good practice and shouldn't be encouraged--they should do a proper quic leave of the channel IMO.)\r\n\r\nAlso worth noting that I'm using plural here on purpose--maybe this points to another thing that (as another separate but loosely related matter) should get some text on how to handle it when there's colliding network paths among the channels?  If that makes any sense I guess we can make an issue about it...\r\n - Note that there's actually a use case for permitting (S,G) collisions: it's useful to deliver integrity frames for your data channel on a different quic channel that uses the same (S,G) (with or without being a different UDP port), because it uses the same routing for both channels so there's fate-sharing for the integrity and data trafic, and that can give a bunch of benefit to the scalability by shipping the integrity traffic over multicast.",
              "createdAt": "2022-04-29T01:12:32Z",
              "updatedAt": "2022-04-29T01:19:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45LwoV",
          "commit": {
            "abbreviatedOid": "9f7b3a5"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "I think that's a good start, thanks.",
          "createdAt": "2022-05-02T18:06:25Z",
          "updatedAt": "2022-05-02T18:06:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOG6NyZs426Kjc",
      "title": "Add ACK Bundle Size",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/18",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some minor things I notice while reading and first attempt at adding ACK bundle size.\r\nWould close #11 ",
      "createdAt": "2022-04-28T00:06:04Z",
      "updatedAt": "2022-04-28T23:19:53Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "67bf5b0c186fcd3e0fb6a9b1fa8d889c879bf524",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue11",
      "headRefOid": "a8d99e31424b377bf961a33b42ccd40a02ce562a",
      "closedAt": "2022-04-28T23:19:53Z",
      "mergedAt": "2022-04-28T23:19:53Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "4a605542f752ba1b3c490966c5e1915a37669066"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs45DLpx",
          "commit": {
            "abbreviatedOid": "a8d99e3"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "LGTM, a very fine start.",
          "createdAt": "2022-04-28T23:19:37Z",
          "updatedAt": "2022-04-28T23:19:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOG6NyZs429Ijz",
      "title": "Some suggested fixes",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/19",
      "state": "MERGED",
      "author": "samhurst",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks for the good document, I think it's a great start. I've got some minor fixes, including some typo corrections and a couple of attempts at rewording some sections that were difficult to parse. Let me know what you think.",
      "createdAt": "2022-04-28T15:21:38Z",
      "updatedAt": "2022-04-28T23:45:40Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "67bf5b0c186fcd3e0fb6a9b1fa8d889c879bf524",
      "headRepository": "samhurst/draft-jholland-quic-multicast",
      "headRefName": "main",
      "headRefOid": "737e2bbf6d3716df0fa3cf6f23dece8c1a66f12a",
      "closedAt": "2022-04-28T23:45:40Z",
      "mergedAt": "2022-04-28T23:45:40Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "737e2bbf6d3716df0fa3cf6f23dece8c1a66f12a"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Thanks for the helpful comments and fixes, they LGTM.",
          "createdAt": "2022-04-28T23:35:06Z",
          "updatedAt": "2022-04-28T23:35:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 20,
      "id": "PR_kwDOG6NyZs42-7XM",
      "title": "attempted fix for issue #10 (session has a meaning via TLS)",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/20",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-28T23:04:13Z",
      "updatedAt": "2022-04-29T00:21:03Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "8a786ee3b34a4620b9d6b0513f04780f60b70f67",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-10",
      "headRefOid": "987d43fddc5d1b2731b4e47dff8c62eb7d74f193",
      "closedAt": "2022-04-29T00:14:09Z",
      "mergedAt": "2022-04-29T00:14:09Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "234520ec2304bb110e8f8268de40bdb6f75ed3d0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOG6NyZs42_OPT",
      "title": "fix issue #21: changed channel id encodings, plus frame spec ending nits",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/22",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-29T00:38:38Z",
      "updatedAt": "2022-04-30T01:26:22Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "234520ec2304bb110e8f8268de40bdb6f75ed3d0",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-21",
      "headRefOid": "c18843dd8d5b8105953c4e08846cdb5108a7c873",
      "closedAt": "2022-04-30T01:26:22Z",
      "mergedAt": "2022-04-30T01:26:22Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "251bc98efbdaa9aa0754677629b3260163f5b15b"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM.",
          "createdAt": "2022-04-30T01:26:18Z",
          "updatedAt": "2022-04-30T01:26:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOG6NyZs43KXDj",
      "title": "Adding part about maintaining forward secrecy",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/25",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #2 ",
      "createdAt": "2022-05-02T11:30:37Z",
      "updatedAt": "2022-05-02T18:08:11Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "251bc98efbdaa9aa0754677629b3260163f5b15b",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue2",
      "headRefOid": "f215e6d287bb46026c00994ada7bc61d6e76af15",
      "closedAt": "2022-05-02T18:08:11Z",
      "mergedAt": "2022-05-02T18:08:11Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "54c778e0460c05284e1c76fdf69c01a5456c699a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs45LxA-",
          "commit": {
            "abbreviatedOid": "f215e6d"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Sure, that works ok.  Thanks.",
          "createdAt": "2022-05-02T18:08:04Z",
          "updatedAt": "2022-05-02T18:08:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOG6NyZs43NLqH",
      "title": "Issue #27 (frame spec cleanup)",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/30",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "(NB: I think this matches the implemented frames so far, did the work in parallel)",
      "createdAt": "2022-05-03T03:53:38Z",
      "updatedAt": "2022-05-04T18:56:36Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "54c778e0460c05284e1c76fdf69c01a5456c699a",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-27",
      "headRefOid": "f4749bf67c1b10b73039edae9d02c7a30341a8da",
      "closedAt": "2022-05-04T18:56:35Z",
      "mergedAt": "2022-05-04T18:56:35Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "c034471c47b3f344e0dbe9add4336d2b6cb32482"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs45PtTY",
          "commit": {
            "abbreviatedOid": "7b8a648"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM, some nits. Though I still think the transport parameter format should be the same as the client_limits frame ( replace Permit IPv4/6 and the reserved with capabilities flag) ",
          "createdAt": "2022-05-03T13:50:10Z",
          "updatedAt": "2022-05-04T00:04:10Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I think this should be an (8) \r\nPer RFC 9000: \r\n`NEW_CONNECTION_ID Frame {\r\n  Type (i) = 0x18,\r\n  Sequence Number (i),\r\n  Retire Prior To (i),\r\n  Length (8),\r\n  Connection ID (8..160),\r\n  Stateless Reset Token (128),\r\n}`",
              "createdAt": "2022-05-03T13:50:10Z",
              "updatedAt": "2022-05-04T00:04:10Z"
            },
            {
              "originalPosition": 52,
              "body": "I think the notation of these might be off, in RFC 9000 three dots indicates a repetition iirc, I think you just want two here. \r\nRFC9000:\r\n`  Arbitrary-Length Field (..)`",
              "createdAt": "2022-05-03T13:55:58Z",
              "updatedAt": "2022-05-04T00:04:10Z"
            },
            {
              "originalPosition": 89,
              "body": "I guess there is one field where no prior value is necessarily known, which is (surprise surprise) source IP in case ASM is used. So I guess this isn't generally true and there needs to be an exception to this rule for that one field. \r\nBut to me it sounds like just another hassle that gets removed by not supporting ASM.",
              "createdAt": "2022-05-03T23:52:30Z",
              "updatedAt": "2022-05-04T00:04:10Z"
            },
            {
              "originalPosition": 24,
              "body": "This is possibly true in several places in this PR",
              "createdAt": "2022-05-03T23:59:04Z",
              "updatedAt": "2022-05-04T00:04:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45WyBK",
          "commit": {
            "abbreviatedOid": "7b8a648"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T17:59:33Z",
          "updatedAt": "2022-05-04T17:59:34Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Yes, I think stripping ASM as a separate PR will clean this up.  Good point. (resolving this since we decided to strip out ASM).",
              "createdAt": "2022-05-04T17:59:33Z",
              "updatedAt": "2022-05-04T18:01:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45WyXd",
          "commit": {
            "abbreviatedOid": "7b8a648"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T18:00:51Z",
          "updatedAt": "2022-05-04T18:00:51Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Thanks, good catch. New update fixes it I think.",
              "createdAt": "2022-05-04T18:00:51Z",
              "updatedAt": "2022-05-04T18:00:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45Wycm",
          "commit": {
            "abbreviatedOid": "7b8a648"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T18:01:08Z",
          "updatedAt": "2022-05-04T18:01:08Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Thanks, good catch.  New update fixes it I think.",
              "createdAt": "2022-05-04T18:01:08Z",
              "updatedAt": "2022-05-04T18:01:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOG6NyZs43Q_GC",
      "title": "Add MC_RESERVE_CHANNEL_IDS frame",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/31",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #9 ",
      "createdAt": "2022-05-04T02:55:14Z",
      "updatedAt": "2022-05-13T15:41:18Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "466873a695c997e960749f56059874aade65589d",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue9",
      "headRefOid": "acc58cb05a0640079f1ad7f2468bb9a96eb8d23f",
      "closedAt": "2022-05-13T15:41:18Z",
      "mergedAt": "2022-05-13T15:41:18Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "399ac7e142888dbcc2ba0402ca69a60dce39bedf"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "This might need a second list with the lengths of the channel IDs, which seemed a bit awkward but I guess it\u2019s necessary? ",
          "createdAt": "2022-05-04T03:23:10Z",
          "updatedAt": "2022-05-04T03:23:10Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Gave it a shot to split the properties frame as well now to maybe make it more straight forward and use the new frame as not only reservation of a Channel ID but also to communicate all the static properties of a channel (into two for now, splitting keys out could also come later)",
          "createdAt": "2022-05-05T00:11:09Z",
          "updatedAt": "2022-05-05T00:11:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs45WM6v",
          "commit": {
            "abbreviatedOid": "e425a3d"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T16:02:39Z",
          "updatedAt": "2022-05-04T16:02:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think a list of { Length, ChannelID } structures is probably better.  There's an existing [WriteLengthPrefixedConnectionId](https://github.com/GrumpyOldTroll/quiche/blob/jake-demo-branch/quic/core/quic_data_writer.h#L88) function that can be used if it's structured that way.",
              "createdAt": "2022-05-04T16:02:40Z",
              "updatedAt": "2022-05-04T16:02:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45WN9_",
          "commit": {
            "abbreviatedOid": "e425a3d"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T16:05:51Z",
          "updatedAt": "2022-05-04T16:05:52Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I guess another option is a separate frame per reserved channel id, like with opening streams or something.  The size overhead you can save by batching them is pretty marginal I think, and comes with complexity if it gets too big for a packet.",
              "createdAt": "2022-05-04T16:05:51Z",
              "updatedAt": "2022-05-04T16:05:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45WoSH",
          "commit": {
            "abbreviatedOid": "e425a3d"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T17:26:22Z",
          "updatedAt": "2022-05-04T17:26:22Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Right, good point about the fragmentation and list format. I guess another option would be to just have a range of reserved channels, so something like\r\n\r\n```\r\nLength start (8),\r\nStart channel ID (8..160),\r\nLength end (8),\r\nEnd channel ID (8..160),\r\n\r\n```\r\nI guess the question is if there is any serious reason why a server would want to have several entirely separate ranges of channel IDs? Or maybe you just allow to send several of those frames, in cases where it is really required? ",
              "createdAt": "2022-05-04T17:26:22Z",
              "updatedAt": "2022-05-04T17:26:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45Y2hW",
          "commit": {
            "abbreviatedOid": "58fc92e"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T02:50:50Z",
          "updatedAt": "2022-05-05T03:25:45Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "They can still arrive out of order, so I'm not sure what this accomplishes...  Might as well add all the property fields too I guess?",
              "createdAt": "2022-05-05T02:50:50Z",
              "updatedAt": "2022-05-05T03:25:45Z"
            },
            {
              "originalPosition": 16,
              "body": "Other things with a single bit-field generally it as the last bit in the frame type, making 2 frame types with 1 thing different between them.  Maybe appropriate here?",
              "createdAt": "2022-05-05T02:57:56Z",
              "updatedAt": "2022-05-05T03:25:45Z"
            },
            {
              "originalPosition": 46,
              "body": "With a 32-byte key and IPv6 I get 124 bytes for this frame, so maybe it's too long for that.  hmm.",
              "createdAt": "2022-05-05T02:59:37Z",
              "updatedAt": "2022-05-05T03:25:45Z"
            },
            {
              "originalPosition": 46,
              "body": "Plus ~90 for the properties as a max size.  Hmm..., not many of these sets per packet.  I guess we probably do need the reservation if we're doing it this way.",
              "createdAt": "2022-05-05T03:09:54Z",
              "updatedAt": "2022-05-05T03:25:45Z"
            },
            {
              "originalPosition": 176,
              "body": "suggest replacing from \"SHOULD ...\" with: \"SHOULD NOT send properties for channels except those the client has joined or will be imminently asked to join.\"",
              "createdAt": "2022-05-05T03:22:34Z",
              "updatedAt": "2022-05-05T03:25:45Z"
            },
            {
              "originalPosition": 182,
              "body": "Suggest adding:\r\nIf a client receives a MC_CHANNEL_JOIN for a channel for which it has not received both, it MUST respond with a MC_CLIENT_CHANNEL_STATE with State \"Declined Join\" and reason \"Missing Properties\".  The server MAY send another MC_CHANNEL_JOIN after retransmitting the MC_CHANNEL_PROPERTIES and receiving an acknowledgement indicating receipt of the MC_CHANNEL_ANNOUNCE.",
              "createdAt": "2022-05-05T03:25:13Z",
              "updatedAt": "2022-05-05T03:25:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs45bkJ8",
          "commit": {
            "abbreviatedOid": "58fc92e"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T15:10:48Z",
          "updatedAt": "2022-05-05T15:10:48Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Yeah, the initial frames are quite large, I got around 204(90 announce+114 properties) Bytes combined for properties and announce in a worst case. That assumes a 20 Byte channel ID (it might make sense to add a recommendation to use low channel ids to decrease the size, since they are used in a lot of frames). The issue is that all the parameters have to get to the client before the join one way or another (though I think there might actually be the case where a client could already join just from the announce frame, it could join the multicast channel and create the tree and so on, just couldn't decrypt/ integrity check the packets it receives. Though that is probably too complicated again), but I think that by having it split this way the server could first send at least 10 or so announce frames in a packet which serve as the reservation and then follow it up with properties (and joins) in the next two packets. I think with your suggested addition of the decline_join when either frame is missing we should be good if they arrive out of order, and you're right there isn't much point to a MUST there, so I changed it to a SHOULD. \r\n\r\nI guess this is somewhere where some implementation experience will be good to see how much of a delay this causes. ",
              "createdAt": "2022-05-05T15:10:48Z",
              "updatedAt": "2022-05-05T15:15:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOG6NyZs43UQ-M",
      "title": "Clarify that only SSM is supported",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/37",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #23. ",
      "createdAt": "2022-05-04T20:30:25Z",
      "updatedAt": "2022-05-05T04:12:23Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "c034471c47b3f344e0dbe9add4336d2b6cb32482",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue23",
      "headRefOid": "928eddd8563b3a8322a1f39b25efd4ca812948cd",
      "closedAt": "2022-05-05T04:12:22Z",
      "mergedAt": "2022-05-05T04:12:22Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "466873a695c997e960749f56059874aade65589d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs45Y8TT",
          "commit": {
            "abbreviatedOid": "928eddd"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-05T04:12:15Z",
          "updatedAt": "2022-05-05T04:12:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOG6NyZs43_M5f",
      "title": "Add text on connection termination",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/38",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #12 ",
      "createdAt": "2022-05-17T22:07:07Z",
      "updatedAt": "2022-05-18T23:19:32Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "00361b7784d8fb0e7deaf711aa2f072bed52d6e9",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue12",
      "headRefOid": "d1e9a7d71757a261e627effa7fad822880c081f7",
      "closedAt": "2022-05-18T23:19:32Z",
      "mergedAt": "2022-05-18T23:19:32Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "7c37be5e113783351ee07e09d0fdaec721f5bbc9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46Mz15",
          "commit": {
            "abbreviatedOid": "2ce2cb8"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Yes, this makes sense and should be stated, thanks.  I flagged a nit and encourage fixing it but otherwise lgtm.",
          "createdAt": "2022-05-18T06:51:35Z",
          "updatedAt": "2022-05-18T06:52:40Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "nit: We should probably use the same \"liveness\" wording from [RFC 9000 10.1](https://www.rfc-editor.org/rfc/rfc9000#name-liveness-testing) instead of \"lively\" and \"liveliness check\".",
              "createdAt": "2022-05-18T06:51:35Z",
              "updatedAt": "2022-05-18T06:52:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOG6NyZs44Dqao",
      "title": "removed MC_CHANNEL_STREAM_BOUNDARY_OFFSET",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/39",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-18T21:59:33Z",
      "updatedAt": "2022-05-18T22:07:19Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "00361b7784d8fb0e7deaf711aa2f072bed52d6e9",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-28",
      "headRefOid": "9d9bfc7be121010730cc972981b37b96b848d183",
      "closedAt": "2022-05-18T22:07:19Z",
      "mergedAt": "2022-05-18T22:07:19Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "ba940a6c6f0a4a3ce8fc2787eeffbd109fbaac1e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46Ro5H",
          "commit": {
            "abbreviatedOid": "9d9bfc7"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-18T22:07:14Z",
          "updatedAt": "2022-05-18T22:07:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOG6NyZs44D2xe",
      "title": "fix max_streams and streams_blocked explanation",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/40",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-18T22:33:58Z",
      "updatedAt": "2022-05-18T23:18:57Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "ba940a6c6f0a4a3ce8fc2787eeffbd109fbaac1e",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-29",
      "headRefOid": "24bff1f05c44e0acba93786d082231c377c893d1",
      "closedAt": "2022-05-18T23:18:52Z",
      "mergedAt": "2022-05-18T23:18:51Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "ef2627ccde25974c689d0f87b0445736f450fdf7"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "fix for #29 ",
          "createdAt": "2022-05-18T22:34:17Z",
          "updatedAt": "2022-05-18T22:34:17Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "also for #14 ",
          "createdAt": "2022-05-18T22:36:09Z",
          "updatedAt": "2022-05-18T22:36:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46Rw-D",
          "commit": {
            "abbreviatedOid": "5090ac2"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks this clearly things up a lot I think. One minor comment. ",
          "createdAt": "2022-05-18T23:01:21Z",
          "updatedAt": "2022-05-18T23:01:58Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Wouldn\u2018t it be enough to just have the client react to the streams exceeding the limit? I think having the server also send a LEAVE frame might not always be perfect, especially in cases where the client just can increase its stream limit. Also, LEAVE frames don\u2019t contain a reason for leaving, which means the client wouldn\u2019t necessarily know why it has to leave the channel. So far it\u2019s mostly clients leaving channels and stating the reason (e.g. rate exceeded).\r\n\r\n\r\nAlso, CHANNEL_STATE Frames Are missing the new reason now I think.",
              "createdAt": "2022-05-18T23:01:21Z",
              "updatedAt": "2022-05-18T23:01:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs46Rye0",
          "commit": {
            "abbreviatedOid": "5090ac2"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-18T23:12:11Z",
          "updatedAt": "2022-05-18T23:12:11Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "That can be a SHOULD instead of a MUST.  I feel like the server should be proactively responsible here if client is not moving its MAX_STREAMS, but it doesn't have to be a hard limit, especially since the server can be out of sync with the channel sender by a bit anyway.\r\n\r\nHmm, I thought I added the reason, but maybe it's in a different branch.  I may have confused myself...",
              "createdAt": "2022-05-18T23:12:11Z",
              "updatedAt": "2022-05-18T23:12:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOG6NyZs44D9m-",
      "title": "Fixed up text for MC_CHANNEL_LEAVE and state-changing.",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/41",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "fix for #32 ",
      "createdAt": "2022-05-18T22:52:16Z",
      "updatedAt": "2022-05-18T23:08:01Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "ba940a6c6f0a4a3ce8fc2787eeffbd109fbaac1e",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-32",
      "headRefOid": "3c08266ff51a66ce00d3e2eb778afa4dfdcb2c7a",
      "closedAt": "2022-05-18T23:08:01Z",
      "mergedAt": "2022-05-18T23:08:01Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "d7569327d42ecbf9f12013760a8aa85f55a3d72c"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "also fixes #36 now",
          "createdAt": "2022-05-18T22:58:35Z",
          "updatedAt": "2022-05-18T22:58:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46Rx43",
          "commit": {
            "abbreviatedOid": "3c08266"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-18T23:07:53Z",
          "updatedAt": "2022-05-18T23:07:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOG6NyZs44Impv",
      "title": "Michaels editorial comments",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/47",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-19T16:44:25Z",
      "updatedAt": "2022-05-23T12:09:50Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "cf346a6a1b57a72d46df66d0ebe66aa3f5514d18",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "mwelzl-comments",
      "headRefOid": "8dd175fa82f0db1e13c8493193afa1b3b3a9f6b3",
      "closedAt": "2022-05-23T12:09:50Z",
      "mergedAt": "2022-05-23T12:09:50Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "f81a18b78c809e1cee09db520e14478e13518a32"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46dZIo",
          "commit": {
            "abbreviatedOid": "5b14aa3"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Thanks for pulling these in, a few nits I noticed in the changes, but then go ahead and merge I think.",
          "createdAt": "2022-05-21T04:15:11Z",
          "updatedAt": "2022-05-21T04:18:45Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "This is a wrong edit.  \"its\" could be changed to \"the channel's\" if its meaning is unclear, but this was a possessive pronoun, not a conjunction of \"it is\".",
              "createdAt": "2022-05-21T04:15:11Z",
              "updatedAt": "2022-05-21T04:18:45Z"
            },
            {
              "originalPosition": 110,
              "body": "This should also be \"the unicast connection\" instead of \"a unicast connection\", right?",
              "createdAt": "2022-05-21T04:17:15Z",
              "updatedAt": "2022-05-21T04:18:45Z"
            },
            {
              "originalPosition": 128,
              "body": "close paren is missing",
              "createdAt": "2022-05-21T04:17:45Z",
              "updatedAt": "2022-05-21T04:18:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDOG6NyZs44OlxX",
      "title": "fixes for MC_CHANNEL_ACK frame",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/54",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-21T04:21:46Z",
      "updatedAt": "2022-05-21T21:42:40Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "7c37be5e113783351ee07e09d0fdaec721f5bbc9",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-53",
      "headRefOid": "1be25b285f9b77921f138786f4080f0198141c1c",
      "closedAt": "2022-05-21T21:42:39Z",
      "mergedAt": "2022-05-21T21:42:39Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "76eb64a6adb98bc53a65dcab75ec9923abcb4100"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2022-05-21T21:42:35Z",
          "updatedAt": "2022-05-21T21:42:35Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 55,
      "id": "PR_kwDOG6NyZs44OmLh",
      "title": "moved AEAD algorithm and hash algorithm to MC_CHANNEL_ANNOUNCE",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/55",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-21T04:32:44Z",
      "updatedAt": "2022-05-21T21:43:39Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "7c37be5e113783351ee07e09d0fdaec721f5bbc9",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-42",
      "headRefOid": "a0b51ae382a9f06ae19fbd66653520533689f00a",
      "closedAt": "2022-05-21T21:43:39Z",
      "mergedAt": "2022-05-21T21:43:39Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "cf346a6a1b57a72d46df66d0ebe66aa3f5514d18"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2022-05-21T21:43:34Z",
          "updatedAt": "2022-05-21T21:43:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOG6NyZs44TGXD",
      "title": "Add channel state diagram",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/56",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Only from the client point of view for now, I think server side might not actually be necessary because its very similar? (Basically just switch send/receive in front of the frames I think) \r\n\r\nCloses #50 ",
      "createdAt": "2022-05-23T14:35:51Z",
      "updatedAt": "2022-05-27T15:40:50Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "f81a18b78c809e1cee09db520e14478e13518a32",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue-50",
      "headRefOid": "ac2b4276e694728b56da0907b953750a7cd93eba",
      "closedAt": "2022-05-27T15:40:50Z",
      "mergedAt": "2022-05-27T15:40:50Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "7a0395991d328eba7b8ef56aced0992baa0edfc2"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess a question would be where \"declined join\" goes, does it just return to unjoined or does it retire the channel (probably not)?",
          "createdAt": "2022-05-23T14:40:16Z",
          "updatedAt": "2022-05-23T14:40:16Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I also didn't include \"Held down\" as a state since I didn't see what interaction would make it transition back to \"unjoined\", so it seemed redundant ",
          "createdAt": "2022-05-23T14:40:55Z",
          "updatedAt": "2022-05-23T14:40:55Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Only have two states, joined and unjoined, remove timeout triggers, have transition from unjoined to unjoined after receiving a leave",
          "createdAt": "2022-05-25T18:43:24Z",
          "updatedAt": "2022-05-25T18:43:24Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "On thinking about it more, didn't add the reflexive arrow for unjoined since the same would also be required for joined when a join arrives and initialized when both join or leave arrive. I think that would make the diagram unnecessarily crowded, this way only action that actually lead to a state change are pictured which I think is consistent. \r\n\r\nAlso added text to deal with retiring a channel better since it feels relevant to the diagram (closes #58)",
          "createdAt": "2022-05-26T15:12:26Z",
          "updatedAt": "2022-05-26T15:12:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46ucr-",
          "commit": {
            "abbreviatedOid": "1cf96f4"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "This is really good, thanks.\r\n\r\nI think I'd probably rather call \"attempting joined\" -> \"joined\" and \"joined\" -> \"confirmed\" or something, but this is really good.\r\n\r\nAlso, I do think we need a similar one for server, the state transitions are from different events I think.",
          "createdAt": "2022-05-25T17:54:53Z",
          "updatedAt": "2022-05-25T17:54:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOG6NyZs44TG8V",
      "title": "Add text about initial timeout",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/57",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Recommendation is based on fact that multicast sender likely is colocated with unicast sender so RTT seemed like the right value to choose, up for discussion though obviously \r\n\r\nCloses #33 ",
      "createdAt": "2022-05-23T14:37:42Z",
      "updatedAt": "2022-05-27T15:49:50Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "f81a18b78c809e1cee09db520e14478e13518a32",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue-33",
      "headRefOid": "0547e990b9fb985ca077abbdf67021991de54941",
      "closedAt": "2022-05-27T15:49:50Z",
      "mergedAt": "2022-05-27T15:49:50Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "6f5cfbea66c732c61a35765e41f9c3591b43f348"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Added another reason to the state frame, but we can probably git rid of two other once the idle_timeout is gone\r\n(  0x10: Held Down and 0x11: Max Idle Time Exceeded)",
          "createdAt": "2022-05-26T15:44:52Z",
          "updatedAt": "2022-05-26T15:44:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46uaUa",
          "commit": {
            "abbreviatedOid": "bee0480"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T17:48:17Z",
          "updatedAt": "2022-05-25T17:48:27Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think this is a SHOULD, I think the timing will be too fuzzy for a MUST here.\r\n\r\nWe might need a section or a reference laying out the issues better.  I think 2xRTT is probably too short, RTT to the server is likely to be much faster than the initial join propagation, since that has hop-by-hop state changes and probably tunnel establishment.  I suspect the right answer is to have an administratively configured default for the client and recommend that it adopt a network-specific recommended initial join delay if one is available, with a default of something like 15s if the local receive network does not provide a recommendation.  The initial join can be quite slow sometimes, especially if there is packet loss somewhere.",
              "createdAt": "2022-05-25T17:48:18Z",
              "updatedAt": "2022-05-25T17:48:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs46uea4",
          "commit": {
            "abbreviatedOid": "bee0480"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T18:00:55Z",
          "updatedAt": "2022-05-25T18:00:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Another option here is to leave it up to the server by default, and say the client MAY leave with a new reason according to a separate timer it that can be configured either administratively or according to advice from the local receive network, but describe that it should be long enough to allow for lost packets during hop-by-hop state establishment for the network path to the multicast sender, which can be slow.\r\n\r\nI kind of like this idea better, I don't think client ever has to leave if no traffic comes, but it MAY have its own override if it wants, and server can of course decide to give up too.",
              "createdAt": "2022-05-25T18:00:55Z",
              "updatedAt": "2022-05-25T18:00:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "PR_kwDOG6NyZs44Tytw",
      "title": "First version of flow diagram",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/59",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Will maybe require some changes depending on #58.\r\n\r\nNot sure if its best to always include the ID and full frame names (makes it unnecessarily wide) \r\n\r\nCloses #51 ",
      "createdAt": "2022-05-23T17:10:14Z",
      "updatedAt": "2022-06-08T18:28:45Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "6f5cfbea66c732c61a35765e41f9c3591b43f348",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue-51",
      "headRefOid": "0f674fce2b408598b471d6c76682f2261000a507",
      "closedAt": "2022-06-08T18:28:45Z",
      "mergedAt": "2022-06-08T18:28:44Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "3b57d4f00e95419d4c976bc2081898c1f3423cb0"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Add channel state upgrade at the end",
          "createdAt": "2022-05-25T18:45:53Z",
          "updatedAt": "2022-05-25T18:45:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46uXBS",
          "commit": {
            "abbreviatedOid": "60b0d85"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-25T17:35:50Z",
          "updatedAt": "2022-05-25T17:35:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOG6NyZs44dd-X",
      "title": "More for Michaels comments",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/60",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #46, #43, and #45 ",
      "createdAt": "2022-05-25T16:52:54Z",
      "updatedAt": "2022-06-13T15:31:39Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "6f5cfbea66c732c61a35765e41f9c3591b43f348",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "mwelzl-comments",
      "headRefOid": "e2dd09dfc9995edd0aa4c42a06274595d5cec12e",
      "closedAt": "2022-06-13T15:31:39Z",
      "mergedAt": "2022-06-13T15:31:39Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "b012dfd605543b07ef708e1aad77d4fae227f360"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Now also closes #24 ",
          "createdAt": "2022-05-27T10:56:10Z",
          "updatedAt": "2022-05-27T10:56:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs46uYW5",
          "commit": {
            "abbreviatedOid": "4ec8417"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T17:40:51Z",
          "updatedAt": "2022-05-25T17:41:43Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think this paragraph needs to refer to https://www.rfc-editor.org/rfc/rfc9000#section-2.2, and basically needs to restate what it says there and emphasize that this spec changes nothing about that handling, it only means there are extra ways that a client endpoint might receive data for a stream multiple times.  I don't think we have a new MUST here, we just have the same MUST from RFC 9000 section 2.2.",
              "createdAt": "2022-05-25T17:40:51Z",
              "updatedAt": "2022-05-25T17:41:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs463cKy",
          "commit": {
            "abbreviatedOid": "58e8fcc"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Looks good with one nit",
          "createdAt": "2022-05-27T14:44:09Z",
          "updatedAt": "2022-05-27T14:44:25Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "There is always now an Until Packet Number, but I think the value 0 could be used here to indicate indefinite termination.",
              "createdAt": "2022-05-27T14:44:09Z",
              "updatedAt": "2022-05-27T14:44:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs47x018",
          "commit": {
            "abbreviatedOid": "d88143a"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T14:52:06Z",
          "updatedAt": "2022-06-10T14:58:10Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Better, but there's still something here bothering me.\r\n\r\nHow about:\r\n\r\n~~~\r\nStream frames for server-initiated streams can be sent on multicast\r\nchannels as well as the unicast connection.  Doing so is only possible\r\nwith stream data that's identical for the same offset and stream ID\r\nacross all receivers on that channel.   Stream data for the same offset\r\nmight also be sent on the unicast channel or on other multicast\r\nchannels.  As described in Section 2.2 of {{RFC9000}}, stream data\r\nreceived multiple times for the same offset MUST be identical;\r\nif it's not identical it MAY be treated as a connection error of type\r\nPROTOCOL_VIOLATION.\r\n~~~\r\n\r\nMaybe that's too wordy, not sure.  The main issues I'm trying to make different in this text:\r\n- I think it's wrong to say it's exactly as in section 2.2 of 9000 because we do differ on flow control, which I think we cover in the next section but also has a MUST in 2.2 of 9000.\r\n- The \"however\" sentence seems strange because handling it when you get the same stream data is already required in 9000 (but is phrased as \"received multiple times\" instead of \"received on multiple channels\").\r\n",
              "createdAt": "2022-06-10T14:52:06Z",
              "updatedAt": "2022-06-10T14:58:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs473-mM",
          "commit": {
            "abbreviatedOid": "94513ab"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-13T15:21:35Z",
          "updatedAt": "2022-06-13T15:21:36Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: typo \"flexceed\" -> \"exceed\"",
              "createdAt": "2022-06-13T15:21:36Z",
              "updatedAt": "2022-06-13T15:21:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOG6NyZs45j_ld",
      "title": "Change MC_CHANNEL_PROPERTIES to MC_CHANNEL_KEY",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/66",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Branched from the other PR, so better to merge that first to see the diff better. (Tried to avoid merge conflicts going forward)",
      "createdAt": "2022-06-13T13:30:21Z",
      "updatedAt": "2022-06-13T15:31:53Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "3b57d4f00e95419d4c976bc2081898c1f3423cb0",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue-64",
      "headRefOid": "d905382ca4f991a040abc41288fabf869235121b",
      "closedAt": "2022-06-13T15:31:53Z",
      "mergedAt": "2022-06-13T15:31:53Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "ea5edd52abb202287cef93b9d4a87aec0bc423e1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 68,
      "id": "PR_kwDOG6NyZs45ln0D",
      "title": "draft-jholland-quic-multicast.md",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/68",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "fix for #67",
      "createdAt": "2022-06-13T20:34:48Z",
      "updatedAt": "2022-06-13T20:38:07Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "ea5edd52abb202287cef93b9d4a87aec0bc423e1",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-67",
      "headRefOid": "523807f439b62c7fec3996fcf81803455e498737",
      "closedAt": "2022-06-13T20:38:07Z",
      "mergedAt": "2022-06-13T20:38:07Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "2bb104a691a0097d09452b7b4dc44d50e6a2c269"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2022-06-13T20:38:02Z",
          "updatedAt": "2022-06-13T20:38:02Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 70,
      "id": "PR_kwDOG6NyZs45-TAT",
      "title": "shorten frame names and diagram widths (#69)",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/70",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "fix for #69 ",
      "createdAt": "2022-06-20T21:09:21Z",
      "updatedAt": "2022-06-21T01:50:53Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "2bb104a691a0097d09452b7b4dc44d50e6a2c269",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-69",
      "headRefOid": "e0e3c1ede5ff879a736022b428ac6f12ec21dc01",
      "closedAt": "2022-06-21T01:50:45Z",
      "mergedAt": "2022-06-21T01:50:45Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "326680d0c9a60d8d6cb4cbbea11d840e27faf9f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs48XkCP",
          "commit": {
            "abbreviatedOid": "e0e3c1e"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-20T23:22:18Z",
          "updatedAt": "2022-06-20T23:22:19Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I think the \"...\" got misaligned somehow?",
              "createdAt": "2022-06-20T23:22:18Z",
              "updatedAt": "2022-06-20T23:22:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48XqAm",
          "commit": {
            "abbreviatedOid": "e0e3c1e"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T00:29:43Z",
          "updatedAt": "2022-06-21T00:29:43Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I have some on each side, I don't see them misaligned?\r\nMaybe the picture is unclear tho.  It's meant to represent ongoing back & forth or something.  Not sure it conveys that well.\r\n",
              "createdAt": "2022-06-21T00:29:43Z",
              "updatedAt": "2022-06-21T00:29:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48XqqF",
          "commit": {
            "abbreviatedOid": "e0e3c1e"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T00:37:48Z",
          "updatedAt": "2022-06-21T00:37:48Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Ah, I was following the examples in RFC9000 where I think they just had them in the middle and not on both sides, but I guess that works too",
              "createdAt": "2022-06-21T00:37:48Z",
              "updatedAt": "2022-06-21T00:37:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48Xw2e",
          "commit": {
            "abbreviatedOid": "e0e3c1e"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-21T01:30:58Z",
          "updatedAt": "2022-06-21T01:30:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOG6NyZs45-cnT",
      "title": "replace max idle time and ack bundle with max ack delay",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/71",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "issue #63 ",
      "createdAt": "2022-06-20T22:21:32Z",
      "updatedAt": "2022-06-21T01:51:16Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "2bb104a691a0097d09452b7b4dc44d50e6a2c269",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-63",
      "headRefOid": "6b13932b3f22c9afd89b684e664b136983e18563",
      "closedAt": "2022-06-21T01:51:12Z",
      "mergedAt": "2022-06-21T01:51:12Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "f59416a4510a5a268106c1d08dfcabd2d2461e8b"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM, pending #70, but can be merged once it does ",
          "createdAt": "2022-06-20T23:23:05Z",
          "updatedAt": "2022-06-20T23:23:05Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 73,
      "id": "PR_kwDOG6NyZs46A8K4",
      "title": "added operational considerations (#61)",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/73",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Mostly #61, but also I think covered #52 and #72 (encryption clarity) and #64 (ordering for join/key/announce)",
      "createdAt": "2022-06-21T09:28:10Z",
      "updatedAt": "2022-06-21T21:38:15Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "f59416a4510a5a268106c1d08dfcabd2d2461e8b",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-61",
      "headRefOid": "0bb49fb38dbf5c7e952c63a586d0f5d3dccaba0f",
      "closedAt": "2022-06-21T21:38:14Z",
      "mergedAt": "2022-06-21T21:38:14Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "c350fa7e7b2c6ffce8db76922e81d310e8a4a47e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs48bFJL",
          "commit": {
            "abbreviatedOid": "c04b211"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks a lot this is a great PR. Some minor comments, most of them might be future issues/todos. \r\n",
          "createdAt": "2022-06-21T14:38:56Z",
          "updatedAt": "2022-06-21T15:14:33Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Is it always necessarily true that they have a different path than the unicast connection? What benefit do we get out of stating this here? I think saying that the channels are unidirectional are a good enough reason to have to send MC_ACKs on the unicast connection",
              "createdAt": "2022-06-21T14:38:56Z",
              "updatedAt": "2022-06-21T15:14:33Z"
            },
            {
              "originalPosition": 167,
              "body": "Should there be some more details on this? Maybe over what period/ by how much etc. This can come later though I think. \r\nIt isn't part of the spec necessarily, but more another operational insight/ guidance. ",
              "createdAt": "2022-06-21T14:48:54Z",
              "updatedAt": "2022-06-21T15:14:33Z"
            },
            {
              "originalPosition": 186,
              "body": "Would the client even be aware of loss on multicast channels? I guess it would see the gaps in the packet numbers, maybe we should also say something about that?",
              "createdAt": "2022-06-21T14:58:53Z",
              "updatedAt": "2022-06-21T15:14:33Z"
            },
            {
              "originalPosition": 450,
              "body": "Should be -01 I think (unless you want to do another rev before sending it to webtransport) ",
              "createdAt": "2022-06-21T15:06:39Z",
              "updatedAt": "2022-06-21T15:14:33Z"
            },
            {
              "originalPosition": 473,
              "body": "I am no expert in language of IETF documents, but \"profitably\" seems off, maybe better to use something like \"efficiently\"? ",
              "createdAt": "2022-06-21T15:08:23Z",
              "updatedAt": "2022-06-21T15:14:33Z"
            },
            {
              "originalPosition": 480,
              "body": "Maybe also add the file delivery/ systems update use case?",
              "createdAt": "2022-06-21T15:09:24Z",
              "updatedAt": "2022-06-21T15:14:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48c8sT",
          "commit": {
            "abbreviatedOid": "c04b211"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T20:42:28Z",
          "updatedAt": "2022-06-21T20:42:28Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "It also can see the integrity frames and see that there are hashes for packet numbers it didn't see.",
              "createdAt": "2022-06-21T20:42:28Z",
              "updatedAt": "2022-06-21T20:42:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48c_Mo",
          "commit": {
            "abbreviatedOid": "c04b211"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T20:52:53Z",
          "updatedAt": "2022-06-21T20:52:53Z",
          "comments": [
            {
              "originalPosition": 480,
              "body": "The FLUTE/FCAST case is meant to be this. I'll add a little color there.",
              "createdAt": "2022-06-21T20:52:53Z",
              "updatedAt": "2022-06-21T20:52:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48c_V3",
          "commit": {
            "abbreviatedOid": "c04b211"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T20:53:27Z",
          "updatedAt": "2022-06-21T20:53:27Z",
          "comments": [
            {
              "originalPosition": 450,
              "body": "clarified that i meant version -02 of webtransport and -04 of h3 datagrams.",
              "createdAt": "2022-06-21T20:53:27Z",
              "updatedAt": "2022-06-21T20:53:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48c_aA",
          "commit": {
            "abbreviatedOid": "c04b211"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T20:53:42Z",
          "updatedAt": "2022-06-21T20:53:42Z",
          "comments": [
            {
              "originalPosition": 473,
              "body": "sure, \"can benefit from using\" instead seems fine.",
              "createdAt": "2022-06-21T20:53:42Z",
              "updatedAt": "2022-06-21T20:53:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48dAOf",
          "commit": {
            "abbreviatedOid": "c04b211"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T20:56:31Z",
          "updatedAt": "2022-06-21T20:56:31Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "The description of Max Rate in the MC_ANNOUNCE frame specifies a 5s window for max rate, but I think we should probably explain that in the flow control section too, yes.  I think it does probably have to be part of the spec (at least as RECOMMENDED or SHOULD or something), otherwise different implementations will not necessarily interoperate well.",
              "createdAt": "2022-06-21T20:56:31Z",
              "updatedAt": "2022-06-21T20:56:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48dAUY",
          "commit": {
            "abbreviatedOid": "c04b211"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T20:56:52Z",
          "updatedAt": "2022-06-21T20:56:52Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "changed the wording here, thanks.",
              "createdAt": "2022-06-21T20:56:52Z",
              "updatedAt": "2022-06-21T20:56:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOG6NyZs46EkXi",
      "title": "fine-tuning of intro text plus minor updates",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/74",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-21T23:19:08Z",
      "updatedAt": "2022-06-22T10:45:04Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "c350fa7e7b2c6ffce8db76922e81d310e8a4a47e",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "tune-intro",
      "headRefOid": "71d2e310dc38660b67c6cb70e22f628fff31fc2f",
      "closedAt": "2022-06-22T10:45:04Z",
      "mergedAt": "2022-06-22T10:45:04Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "25236b4cb9c2283ba5a79b911be14b3a9cd7e91e"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "Not exactly a specific raised issue for these, but I made a pass that I think cleans up a few things.",
          "createdAt": "2022-06-21T23:20:01Z",
          "updatedAt": "2022-06-21T23:20:01Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2022-06-22T10:45:00Z",
          "updatedAt": "2022-06-22T10:45:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 76,
      "id": "PR_kwDOG6NyZs46NjZT",
      "title": "touch up recovery and congestion control text",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/76",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "text for 2 of the 3 points we (Max & I) discussed offline earlier today.\r\nFor the other point, I opened an issue with some tentative text and a discussion kickoff, but I'm not sure I've captured the right idea, so I'm leaving it open for a later rev:\r\nhttps://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/issues/75",
      "createdAt": "2022-06-23T05:31:57Z",
      "updatedAt": "2022-06-23T17:02:15Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "25236b4cb9c2283ba5a79b911be14b3a9cd7e91e",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "offline-comments",
      "headRefOid": "727e420db4bbafbf0b339d742d03c02892c0731a",
      "closedAt": "2022-06-23T17:02:15Z",
      "mergedAt": "2022-06-23T17:02:15Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "9635a77954574ca4fcb12856ee75774547f3273a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs48nJMO",
          "commit": {
            "abbreviatedOid": "703be86"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, two comments but can be merged as is as well.",
          "createdAt": "2022-06-23T12:14:35Z",
          "updatedAt": "2022-06-23T12:15:47Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I think the comment in the parentheses is making this a bit confusing to me, I think it would be fine to leave it out.\r\n\r\nI also now wonder if the client unilaterally leaving channels might cause more issues than it solves as the server probably has a better understanding on what channels to leave in what order. Maybe the client should simply reduce its max rate which will lead to the server sending leave frames? Not sure, but I think its fine for now and we can think more about it in a later rev. ",
              "createdAt": "2022-06-23T12:14:35Z",
              "updatedAt": "2022-06-23T12:15:47Z"
            },
            {
              "originalPosition": 26,
              "body": "Should there be a mention on difference between DGRAM and STREAM frames here? I think that might be a clearer separation between what is necessary data and what is not.",
              "createdAt": "2022-06-23T12:15:01Z",
              "updatedAt": "2022-06-23T12:15:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48o0uq",
          "commit": {
            "abbreviatedOid": "703be86"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T16:37:44Z",
          "updatedAt": "2022-06-23T16:37:44Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "While I agree the server has a better view, I think there's risk that it takes a long time with an impaired network if the unicast connection is suffering loss and can't get the MC_LIMITS sent quickly or the MC_LEAVE received quickly, and it's also no different than the client refusing any particular channel it chooses to refuse or the network refusing to forward a channel.  After leaving and reducing limits, the server can still tell the client to leave one channel and join another, and failing to optimize which channel was best to leave probably just means some extra recovery or something.\r\n\r\nI'll take out the parens, thanks.",
              "createdAt": "2022-06-23T16:37:44Z",
              "updatedAt": "2022-06-23T16:37:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs48o36R",
          "commit": {
            "abbreviatedOid": "703be86"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T16:48:16Z",
          "updatedAt": "2022-06-23T16:48:17Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Other kinds of frames besides streams also need to be retransmitted (like RESET_STREAM, as well as MC_INTEGRITY, MC_RETIRE, MC_LEAVE).  Likewise other kinds of frames besides DATAGRAM frames don't get retransmitted (like PING and PADDING).  I tried to leave it generic, but maybe we need a reference to https://www.rfc-editor.org/rfc/rfc9000.html#section-13.3 and https://www.rfc-editor.org/rfc/rfc9221.html#section-5.2 plus a similar section in this doc to list what gets retransmitted?",
              "createdAt": "2022-06-23T16:48:16Z",
              "updatedAt": "2022-06-23T16:48:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOG6NyZs46vy0Z",
      "title": "updated text for operational considerations (fixed webtrans streams e\u2026",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/78",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026xplanation, refined constraints a bit)",
      "createdAt": "2022-07-02T23:17:01Z",
      "updatedAt": "2022-07-06T18:08:26Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "9635a77954574ca4fcb12856ee75774547f3273a",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "fix-ops-guidance",
      "headRefOid": "5e2e511a5949bce71b33855ee3f5c39ff0727c37",
      "closedAt": "2022-07-06T17:13:50Z",
      "mergedAt": "2022-07-06T17:13:50Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "953cc3424f5e061c2539439d9df9540177294cef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs49M6fZ",
          "commit": {
            "abbreviatedOid": "6bf893e"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One nit but otherwise LGTM ",
          "createdAt": "2022-07-02T23:56:47Z",
          "updatedAt": "2022-07-03T00:02:58Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "A bit confusing what \u201eThis\u201c is referring to here (similar in the one above), maybe scratch the first 3 words? ",
              "createdAt": "2022-07-02T23:56:47Z",
              "updatedAt": "2022-07-03T00:02:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOG6NyZs460pWB",
      "title": "nits: spellcheck",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/79",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-04T23:38:03Z",
      "updatedAt": "2022-07-06T16:25:18Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "9635a77954574ca4fcb12856ee75774547f3273a",
      "headRepository": "LPardue/draft-jholland-quic-multicast",
      "headRefName": "spellcheck",
      "headRefOid": "51e1ff6818423012a8ec5fc082001371df44a5e0",
      "closedAt": "2022-07-06T16:25:18Z",
      "mergedAt": "2022-07-06T16:25:18Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "211fbe952fe9a82dcda83a60ac8ab09cecf22535"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 80,
      "id": "PR_kwDOG6NyZs460qLk",
      "title": "nits: hyperlink sections in other drafts",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/80",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "You won't believe this one cool trick that will change your life*\n\n* not _that) cool, unlikely to change your life, might require\n  an update to your tooling\n",
      "createdAt": "2022-07-04T23:51:19Z",
      "updatedAt": "2022-07-06T16:18:58Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "9635a77954574ca4fcb12856ee75774547f3273a",
      "headRepository": "LPardue/draft-jholland-quic-multicast",
      "headRefName": "hyperlink-sections",
      "headRefOid": "13bb965fa9d4a31b50a79c4a8095a53415c9cc0b",
      "closedAt": "2022-07-06T16:18:58Z",
      "mergedAt": "2022-07-06T16:18:57Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "3e0723573e400c76b96e824a0bd69e4c520fb453"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "This looks like an amazing and life-changing approach that I would love to apply, but when I build locally I get errors.\r\n\r\nCan you say more about this \"update your tooling\" idea?  I did a `pip install --upgrade xml2rfc`, but no joy. What am I missing that makes it say this?:\r\n\r\n~~~\r\n$ make\r\ncat draft-jholland-quic-multicast.md  | kramdown-rfc2629 --v3 | lib/add-note.py | xml2rfc -q -s 'Setting consensus=\"true\" for IETF STD document' --rfc-base-url https://www.rfc-editor.org/rfc/ --id-base-url https://datatracker.ietf.org/doc/html/ --cache=/Users/jholland/.cache/xml2rfc --v2v3 /dev/stdin -o /dev/stdout >draft-jholland-quic-multicast.xml\r\n*** attributes left {\"v\"=>3, \"venue\"=>{\"group\"=>\"QUIC\", \"type\"=>\"Individual Draft\", \"mail\"=>\"quic@ietf.org\", \"arch\"=>\"https://mailarchive.ietf.org/arch/browse/quic/\", \"github\"=>\"GrumpyOldTroll/draft-jholland-quic-multicast\", \"latest\"=>\"https://GrumpyOldTroll.github.io/draft-jholland-quic-multicast/draft-jholland-quic-multicast.html\"}}!\r\n/Users/jholland/.cache/xml2rfc/reference.I-D.draft-krose-multicast-security.xml: renewing (stale by 3.7 days)\r\n/Users/jholland/.cache/xml2rfc/reference.I-D.draft-ietf-mboned-ambi.xml: renewing (stale by 3.7 days)\r\n/Users/jholland/.cache/xml2rfc/reference.I-D.draft-ietf-mboned-cbacc.xml: renewing (stale by 3.7 days)\r\n/Users/jholland/.cache/xml2rfc/reference.I-D.draft-ietf-quic-multipath.xml: renewing (stale by 3.7 days)\r\n/Users/jholland/.cache/xml2rfc/reference.I-D.draft-ietf-webtrans-http3.xml: renewing (stale by 3.7 days)\r\n/Users/jholland/.cache/xml2rfc/reference.I-D.draft-ietf-masque-h3-datagram.xml: renewing (stale by 3.7 days)\r\nxml2rfc -q -s 'Setting consensus=\"true\" for IETF STD document' --rfc-base-url https://www.rfc-editor.org/rfc/ --id-base-url https://datatracker.ietf.org/doc/html/ --cache=/Users/jholland/.cache/xml2rfc draft-jholland-quic-multicast.xml -o draft-jholland-quic-multicast.txt --text --no-pagination\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_19.1_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_7.3_of_RFC8446\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_7.3_of_RFC8446\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_18.2_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_2.2_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_19.11_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_4.6_of_RFC9114\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_4_of_RFC9221\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Sections_4.6_and_19.14_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_12.2_of_I-D.draft-ietf-quic-multipath\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_10_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_17.3.1_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_17.1_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_4.1.1_of_RFC8085\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_19.4_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_19.2_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_5.2_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_5_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_6_of_RFC4607\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_2.1_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_19.8_of_RFC9000\", at None\r\ndraft-jholland-quic-multicast.xml(0): Error: IDREF attribute target references an unknown ID \"Section_4.1_of_RFC8085\", at None\r\n/Users/jholland/src/github/draft-jholland-quic-multicast/draft-jholland-quic-multicast.xml(13): Error: Invalid document before running preptool.\r\nUnable to complete processing draft-jholland-quic-multicast.xml\r\nmake: *** [draft-jholland-quic-multicast.txt] Error 1\r\nrm draft-jholland-quic-multicast.xml\r\n\r\n~~~",
          "createdAt": "2022-07-06T16:10:13Z",
          "updatedAt": "2022-07-06T16:10:13Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "OK, nm.  `sudo gem install kramdown-rfc` fixed it, thanks.  I've been wanting this since the recent changes to the submit page, and didn't know what had happened.",
          "createdAt": "2022-07-06T16:17:58Z",
          "updatedAt": "2022-07-06T16:17:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 81,
      "id": "PR_kwDOG6NyZs460qYu",
      "title": "nits: capitalize ID",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/81",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-04T23:55:16Z",
      "updatedAt": "2022-07-06T16:23:16Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "3e0723573e400c76b96e824a0bd69e4c520fb453",
      "headRepository": "LPardue/draft-jholland-quic-multicast",
      "headRefName": "nits-ID-caps",
      "headRefOid": "9378fb88bdcde198e0605c9f0129aa56fcf9b7e5",
      "closedAt": "2022-07-06T16:23:16Z",
      "mergedAt": "2022-07-06T16:23:15Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "742b5aa6f7c03fcf08804d29cea44dac5d96a229"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 96,
      "id": "PR_kwDOG6NyZs47B6-K",
      "title": "Adressing several of Lucas comments",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/96",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #83, #84, #89, #90, #91 and #94 ",
      "createdAt": "2022-07-07T14:45:59Z",
      "updatedAt": "2022-07-07T15:35:51Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "953cc3424f5e061c2539439d9df9540177294cef",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "lucas-comments",
      "headRefOid": "4a3df47ef0101c35d55aee2a8aea76b0f7187e2f",
      "closedAt": "2022-07-07T15:35:51Z",
      "mergedAt": "2022-07-07T15:35:50Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "fa664bb279efd92bfc2473869dd9df440ae102ed"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "lgtm",
          "createdAt": "2022-07-07T15:35:46Z",
          "updatedAt": "2022-07-07T15:35:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 97,
      "id": "PR_kwDOG6NyZs47Ipur",
      "title": "Added server transport parameter",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/97",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "address #95",
      "createdAt": "2022-07-09T01:38:24Z",
      "updatedAt": "2022-07-10T00:58:28Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "fa664bb279efd92bfc2473869dd9df440ae102ed",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-95",
      "headRefOid": "03787ee46c3264b966b89e4a4d11f345dfb35e53",
      "closedAt": "2022-07-09T12:50:48Z",
      "mergedAt": "2022-07-09T12:50:48Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "a91a989abc5befc8f879631bca73a0b8fd7094f1"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "I think it's good to have both because the server can go ahead and send MC_xxx frames in the first response packet, and we don't have to wait for the unicast handshake to complete before we can start sending MC_LIMITS and then wait for the MC_LIMITS before sending an MC_ANNOUNCE, MC_KEY, and MC_JOIN.  So this saves a round trip I think.",
          "createdAt": "2022-07-10T00:34:23Z",
          "updatedAt": "2022-07-10T00:34:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to both, transport parameters are cheap and help endpoints coordinate what they are doing very early in the connection.",
          "createdAt": "2022-07-10T00:57:41Z",
          "updatedAt": "2022-07-10T00:57:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs49mki_",
          "commit": {
            "abbreviatedOid": "03787ee"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, I guess we now might no longer need the client side parameter as the client can just send a limit frame if it sees the server parameter? I think it\u2019s good to have both for now though.",
          "createdAt": "2022-07-09T12:50:41Z",
          "updatedAt": "2022-07-09T12:50:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOG6NyZs47IqyG",
      "title": "explain the requirements on key deletion",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/98",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "tries to address:\r\n- #92\r\n- #93 ",
      "createdAt": "2022-07-09T02:10:06Z",
      "updatedAt": "2022-07-09T13:22:30Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "fa664bb279efd92bfc2473869dd9df440ae102ed",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-92-93",
      "headRefOid": "ee836bb9198b287d3ef8aeb32ab77c160d423a5a",
      "closedAt": "2022-07-09T12:52:41Z",
      "mergedAt": "2022-07-09T12:52:41Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "f0c719344824b34e92a4f8f0f5eb4146d192b258"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2022-07-09T12:52:37Z",
          "updatedAt": "2022-07-09T12:52:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "This text explains all the rationale in good detail, thanks.",
          "createdAt": "2022-07-09T13:22:30Z",
          "updatedAt": "2022-07-09T13:22:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 99,
      "id": "PR_kwDOG6NyZs47Irmw",
      "title": "tighten up the small bit fields",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/99",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "tries to address:\r\n- #82 \r\n- #85 \r\n\r\nI think it partially addresses #86 also, but I'm not sure it fully covers the GREASE suggestion.",
      "createdAt": "2022-07-09T02:35:17Z",
      "updatedAt": "2022-07-11T14:05:35Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "fa664bb279efd92bfc2473869dd9df440ae102ed",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issues-82-85-86",
      "headRefOid": "d6e57b2f01f501fef1f3b7bd9f9d03304810e986",
      "closedAt": "2022-07-11T14:05:31Z",
      "mergedAt": "2022-07-11T14:05:31Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "fd10b7a8e750e98fd58cd486c6f562eae7ecddf9"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM, one nit ",
          "createdAt": "2022-07-09T12:53:36Z",
          "updatedAt": "2022-07-09T12:54:52Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "general comment: we might benefit from saying what to do with the spare fields. For example, RFC 9113 says \"Unused flags MUST be ignored on receipt and MUST be left unset (0x00) when sending.\"",
          "createdAt": "2022-07-09T13:41:08Z",
          "updatedAt": "2022-07-09T13:41:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs49mlKL",
          "commit": {
            "abbreviatedOid": "6c91b70"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-09T12:54:31Z",
          "updatedAt": "2022-07-09T12:54:32Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Should probably also be MC_EXTENSION_ERROR now?",
              "createdAt": "2022-07-09T12:54:31Z",
              "updatedAt": "2022-07-09T12:54:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs49moSJ",
          "commit": {
            "abbreviatedOid": "6c91b70"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-09T13:31:32Z",
          "updatedAt": "2022-07-09T13:31:32Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Is the field bid-endian or little-endian?",
              "createdAt": "2022-07-09T13:31:32Z",
              "updatedAt": "2022-07-09T13:31:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs49moUY",
          "commit": {
            "abbreviatedOid": "6c91b70"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-09T13:33:40Z",
          "updatedAt": "2022-07-09T13:33:40Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "nit: here it is called \"Capabilities Field\" while in the frame definition it is called \"Capabilities Flags\"",
              "createdAt": "2022-07-09T13:33:40Z",
              "updatedAt": "2022-07-09T13:33:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs49myf2",
          "commit": {
            "abbreviatedOid": "6c91b70"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-10T00:19:14Z",
          "updatedAt": "2022-07-10T00:19:15Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "For an 8-bit field there's no difference between big and little endian, is there?  But I suppose a bit diagram is appropriate here to show which bit position.",
              "createdAt": "2022-07-10T00:19:14Z",
              "updatedAt": "2022-07-10T00:19:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs49my4O",
          "commit": {
            "abbreviatedOid": "d6e57b2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-10T00:52:13Z",
          "updatedAt": "2022-07-10T00:52:13Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "ah I'll correct myself, QUIC is pretty clear in https://www.rfc-editor.org/rfc/rfc9000.html#section-1.3-5 on that.\r\nBut doing it with explicit field values as in the diagram works well too.\r\n\r\n",
              "createdAt": "2022-07-10T00:52:13Z",
              "updatedAt": "2022-07-10T00:52:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs49my4b",
          "commit": {
            "abbreviatedOid": "d6e57b2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-10T00:52:23Z",
          "updatedAt": "2022-07-10T00:52:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDOG6NyZs47IsHO",
      "title": "explain MC_INTEGRITY in channels/ref. merkle tree",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/100",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "address #87 ",
      "createdAt": "2022-07-09T02:52:05Z",
      "updatedAt": "2022-07-09T12:57:01Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "fa664bb279efd92bfc2473869dd9df440ae102ed",
      "headRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "headRefName": "issue-87",
      "headRefOid": "29209ed6036e1f198acf5a641462b24e20f4f16e",
      "closedAt": "2022-07-09T12:57:01Z",
      "mergedAt": "2022-07-09T12:57:01Z",
      "mergedBy": "MaxF12",
      "mergeCommit": {
        "oid": "9de12ba8141903161e94906aaca320f00a9d045b"
      },
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2022-07-09T12:56:55Z",
          "updatedAt": "2022-07-09T12:56:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 108,
      "id": "PR_kwDOG6NyZs489tJl",
      "title": "Issues 104 and 105",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/108",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #104 and #105 ",
      "createdAt": "2022-08-10T14:44:06Z",
      "updatedAt": "2022-08-11T04:52:30Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "fd10b7a8e750e98fd58cd486c6f562eae7ecddf9",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue_104",
      "headRefOid": "b5576be19f9c1e8290e9c6988fe02fe6d0802e3f",
      "closedAt": "2022-08-11T04:52:30Z",
      "mergedAt": "2022-08-11T04:52:30Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "94dac300f23affdbbc245ad2ded1abcedec88940"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs4_uk23",
          "commit": {
            "abbreviatedOid": "b5576be"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "lgtm, thanks!",
          "createdAt": "2022-08-11T04:52:22Z",
          "updatedAt": "2022-08-11T04:52:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDOG6NyZs49g95J",
      "title": "Change wording in Section 2",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/122",
      "state": "MERGED",
      "author": "momoka0122y",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello. Thank you for your interesting work. \r\nThis draft is very interesting. I hope to be able to implement this.\r\n\r\nAdded the words \"Channels only support source-specific multicast (SSM)\".\r\nI apologize in advance if this was unnecessary.",
      "createdAt": "2022-08-21T14:05:35Z",
      "updatedAt": "2022-08-26T15:39:28Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "94dac300f23affdbbc245ad2ded1abcedec88940",
      "headRepository": "momoka0122y/draft-jholland-quic-multicast",
      "headRefName": "patch-1",
      "headRefOid": "ec311c700f684a9c491efaf438162c4060f37906",
      "closedAt": "2022-08-26T15:39:08Z",
      "mergedAt": "2022-08-26T15:39:08Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "14d73a6c07a79ba1c83074f49adab8645b1cd7fa"
      },
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "body": "And thanks :)",
          "createdAt": "2022-08-26T15:39:28Z",
          "updatedAt": "2022-08-26T15:39:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs5AzI15",
          "commit": {
            "abbreviatedOid": "ec311c7"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2022-08-26T15:36:14Z",
          "updatedAt": "2022-08-26T15:36:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOG6NyZs491Hd9",
      "title": "Martins Review, in part",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/123",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #110 #113 #118 #120 and #121, also adds acknowledgements",
      "createdAt": "2022-08-25T23:27:32Z",
      "updatedAt": "2022-08-31T18:08:03Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "94dac300f23affdbbc245ad2ded1abcedec88940",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "martins-review",
      "headRefOid": "00bb4a53874ac69b4c1de51dd27cc32b9e298e3d",
      "closedAt": "2022-08-31T18:08:03Z",
      "mergedAt": "2022-08-31T18:08:03Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "0e37476de9d64c9c1a1cfa08606ac3ff7242ab3f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs5Av1fI",
          "commit": {
            "abbreviatedOid": "0c33216"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T01:22:11Z",
          "updatedAt": "2022-08-26T01:22:12Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Possibly clearer to read as\r\n\r\n> Sending an MC_ANNOUNCE before an MC_JOIN ensures the client can establish the necessary state required to join and retire any connection IDs that might collide with channel IDs.",
              "createdAt": "2022-08-26T01:22:12Z",
              "updatedAt": "2022-08-26T01:22:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5Av2ui",
          "commit": {
            "abbreviatedOid": "0c33216"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T01:32:41Z",
          "updatedAt": "2022-08-26T01:32:42Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nSeparating announcement of channels from joining them allows clients to leave and later rejoining channels at their discretion without the cost of terminating a connection. This could, for example, be used by clients to temporarily disabling multicast reception in response to a high rate of loss or a switch to a network that does not support multicast.\r\n```",
              "createdAt": "2022-08-26T01:32:41Z",
              "updatedAt": "2022-08-26T01:32:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5Av3Cs",
          "commit": {
            "abbreviatedOid": "0c33216"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T01:35:29Z",
          "updatedAt": "2022-08-26T01:35:29Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nThis usually means that new streams must be started for application data carried in channel packets whenever there might be new clients that have joined since an earlier stream started. If the server deems it convenient, it could also send preceding data for that stream over the unicast connection to catch the client up.\r\n```",
              "createdAt": "2022-08-26T01:35:29Z",
              "updatedAt": "2022-08-26T01:35:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5Av5Ad",
          "commit": {
            "abbreviatedOid": "0c33216"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo nits. I spun off issue #124 so that we can merge this issue and make progress.",
          "createdAt": "2022-08-26T01:52:13Z",
          "updatedAt": "2022-08-26T01:52:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG6NyZs5AzKbx",
          "commit": {
            "abbreviatedOid": "61f25ca"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T15:41:39Z",
          "updatedAt": "2022-08-26T16:40:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This is the algorithms both for payloads and for headers.\r\nI'm not totally clear on why the header protection is not aead, but I think this is \"encryption algorithms\" maybe, if aead isn't correct.",
              "createdAt": "2022-08-26T15:41:40Z",
              "updatedAt": "2022-08-26T16:40:17Z"
            },
            {
              "originalPosition": 35,
              "body": "this sentence has a few problems I think:\r\n\r\n- nits: \"leave and later rejoining channels\" -> \"leave and later rejoin channels\", and similarly: \"used by clients to temporarily disabling\" -> \"used by clients to temporarily disable\"\r\n- \"at their discretion\" applies only to the leaving, they cannot rejoin if they've sent a MC_STATE(Leave) unless server instructs them to do so.  Unless you're saying they could leave at the network layer without the corresponding state change in the quic connection telling the server they left?  I was assuming that's not allowed and would indicate a buggy client, but maybe we should explicitly state our expectations about that somewhere...",
              "createdAt": "2022-08-26T16:05:54Z",
              "updatedAt": "2022-08-26T16:40:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5AzcVP",
          "commit": {
            "abbreviatedOid": "61f25ca"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T16:45:22Z",
          "updatedAt": "2022-08-26T16:45:23Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "agree with all points",
              "createdAt": "2022-08-26T16:45:23Z",
              "updatedAt": "2022-08-26T16:45:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5AzdnV",
          "commit": {
            "abbreviatedOid": "61f25ca"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T16:50:07Z",
          "updatedAt": "2022-08-26T16:50:07Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Huh, I had more typed in here, not sure how it got lost.\r\n\r\nI continued to say that maybe we should drop the 2nd line justifying why announce is separated from join, and discuss that offline instead.\r\n\r\nI don't think the doc has to include justification for all the design decisions, and we should maybe discuss offline whether and why we think it's the right design decision, as I don't think this quite covers it to me.  (I don't expect it would cost terminating a connection to leave and rejoin, for instance.)\r\n\r\nI do think it's right to keep join and announce separated, but I think the biggest reason is about being able to assume stability of the channel properties during a join/leave cycle, since I think you get more weird corner cases if client has to handle a leave followed by a join that has different properties, especially once you think about what happens if a frame was dropped.\r\n\r\nI think separating channel existence into announce/retire and channel subscription into join/leave probably makes the implementations tend to be cleaner, assuming we can legitimately get somewhat frequent join/leave cycles on the order of a few seconds, but I think we can just say that in email instead of in the doc.",
              "createdAt": "2022-08-26T16:50:07Z",
              "updatedAt": "2022-08-26T16:50:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5AzeG6",
          "commit": {
            "abbreviatedOid": "61f25ca"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T16:51:52Z",
          "updatedAt": "2022-08-26T16:51:52Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "(the 2nd biggest reason is that it's something like 20x bigger to do a leave+re-join, which seems like a lot to me even for control junk, since I do think we expect it in normal operation sometimes.)",
              "createdAt": "2022-08-26T16:51:52Z",
              "updatedAt": "2022-08-26T16:51:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5AzfUr",
          "commit": {
            "abbreviatedOid": "61f25ca"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-26T16:56:35Z",
          "updatedAt": "2022-08-26T16:56:36Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "> I think separating channel existence into announce/retire and channel subscription into join/leave probably makes the implementations tend to be cleaner, assuming we can legitimately get somewhat frequent join/leave cycles on the order of a few seconds, but I think we can just say that in email instead of in the doc.\r\n\r\nYeah I tend to agree. There's techniques that application can employ to make channel hopping beneficial, especially when the delay is minimal. The transport specification doesn't need to get bogged down with that detail, if we agree elsewhere that is something beneficial to support.",
              "createdAt": "2022-08-26T16:56:35Z",
              "updatedAt": "2022-08-26T16:56:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5A16WY",
          "commit": {
            "abbreviatedOid": "61f25ca"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-28T14:52:35Z",
          "updatedAt": "2022-08-28T14:52:36Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Sure, I agree that maybe the justification doesn't have to be in the draft, removed the line and noted it down for later justification of design decisions if necessary (I made an issue in my fork, I will add any similar things if they pop up there so we can keep track, feel free to add any additional ones as well: https://github.com/MaxF12/draft-jholland-quic-multicast/issues/4) ",
              "createdAt": "2022-08-28T14:52:35Z",
              "updatedAt": "2022-08-28T14:52:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5BGzhx",
          "commit": {
            "abbreviatedOid": "00bb4a5"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2022-08-31T18:07:54Z",
          "updatedAt": "2022-08-31T18:07:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDOG6NyZs5B-CSD",
      "title": "First draft for path migration",
      "url": "https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast/pull/127",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Would close #13 ",
      "createdAt": "2022-11-01T13:58:25Z",
      "updatedAt": "2022-11-15T19:08:39Z",
      "baseRepository": "GrumpyOldTroll/draft-jholland-quic-multicast",
      "baseRefName": "main",
      "baseRefOid": "0e37476de9d64c9c1a1cfa08606ac3ff7242ab3f",
      "headRepository": "MaxF12/draft-jholland-quic-multicast",
      "headRefName": "issue-13",
      "headRefOid": "65615ae8710414598e7bb14fb6110ac9fa4a7d07",
      "closedAt": "2022-11-15T19:08:39Z",
      "mergedAt": "2022-11-15T19:08:39Z",
      "mergedBy": "GrumpyOldTroll",
      "mergeCommit": {
        "oid": "5b9c818aaf7ca99273c86ab616db9d627a0aebd6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG6NyZs5FWqPO",
          "commit": {
            "abbreviatedOid": "8418bae"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I'll suggest s/whos/whose/ as another typo on line 401",
          "createdAt": "2022-11-01T15:41:09Z",
          "updatedAt": "2022-11-01T15:41:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG6NyZs5FWsEm",
          "commit": {
            "abbreviatedOid": "ade0d2a"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-01T15:43:43Z",
          "updatedAt": "2022-11-01T15:43:44Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I thought the server should not send a leave in this situation, but it might cause unicast retransmits?",
              "createdAt": "2022-11-01T15:43:44Z",
              "updatedAt": "2022-11-01T15:44:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5FWtU2",
          "commit": {
            "abbreviatedOid": "ade0d2a"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-01T15:45:47Z",
          "updatedAt": "2022-11-01T15:45:48Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think s/is not able to rejoin/does not rejoin/ removes an ambiguous loophole.",
              "createdAt": "2022-11-01T15:45:47Z",
              "updatedAt": "2022-11-01T15:45:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5GZs_B",
          "commit": {
            "abbreviatedOid": "ade0d2a"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-15T16:00:32Z",
          "updatedAt": "2022-11-15T16:00:33Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "You're right, I think its not specified if the server should fall back to unicast and/or send a leave (and I think it should stay that way). ",
              "createdAt": "2022-11-15T16:00:32Z",
              "updatedAt": "2022-11-15T16:00:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG6NyZs5GavGd",
          "commit": {
            "abbreviatedOid": "65615ae"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-11-15T19:08:31Z",
          "updatedAt": "2022-11-15T19:08:31Z",
          "comments": []
        }
      ]
    }
  ]
}